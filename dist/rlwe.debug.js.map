{"version":3,"file":"dist/rlwe.debug.js","sources":["libsodium/src/libsodium/sodium/utils.c","libsodium/src/libsodium/randombytes/randombytes.c","libsodium/src/libsodium/crypto_stream/chacha20/stream_chacha20.c","libsodium/src/libsodium/crypto_stream/chacha20/ref/stream_chacha20_ref.c","libsodium/src/libsodium/include/sodium/private/common.h","LatticeCrypto_v1.0/generic/ntt.c","LatticeCrypto_v1.0/kex.c","LatticeCrypto_v1.0/random.c","rlwe.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA;AADA;AAEA;;AAEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;;AC1BA;AAAA;;;;;AAeA;AA4BA;;;;;;;;;;AAsCA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACuMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;;AAVA;AAUA;AAAA;;;;;;;;;;;;;;AA/LA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;ADOA;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmIA;;AAhIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAXA;AAAA;AAAA;AAAA;A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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;AAAA;AAAA;;AAgBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAaA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;AAAA;AAAA;;AAeA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAaA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AACA;AAAA;AAyCA;AAAA;;AAlCA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7BA;AAAA;AAAA;;AAiCA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;AA4BA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","sourcesContent":["#ifndef __STDC_WANT_LIB_EXT1__\n# define __STDC_WANT_LIB_EXT1__ 1\n#endif\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_SYS_MMAN_H\n# include <sys/mman.h>\n#endif\n\n#ifdef _WIN32\n# include <windows.h>\n# include <wincrypt.h>\n#else\n# include <unistd.h>\n#endif\n\n#include \"utils.h\"\n#include \"randombytes.h\"\n\n#ifndef ENOSYS\n# define ENOSYS ENXIO\n#endif\n\n#if defined(_WIN32) && (!defined(WINAPI_FAMILY) || WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)\n# define WINAPI_DESKTOP\n#endif\n\n#define CANARY_SIZE 16U\n#define GARBAGE_VALUE 0xd0\n\n#ifndef MAP_NOCORE\n# define MAP_NOCORE 0\n#endif\n#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)\n# define MAP_ANON MAP_ANONYMOUS\n#endif\n#if defined(WINAPI_DESKTOP) || (defined(MAP_ANON) && defined(HAVE_MMAP)) || defined(HAVE_POSIX_MEMALIGN)\n# define HAVE_ALIGNED_MALLOC\n#endif\n#if defined(HAVE_MPROTECT) && !(defined(PROT_NONE) && defined(PROT_READ) && defined(PROT_WRITE))\n# undef HAVE_MPROTECT\n#endif\n#if defined(HAVE_ALIGNED_MALLOC) && (defined(WINAPI_DESKTOP) || defined(HAVE_MPROTECT))\n# define HAVE_PAGE_PROTECTION\n#endif\n#if !defined(MADV_DODUMP) && defined(MADV_CORE)\n# define MADV_DODUMP   MADV_CORE\n# define MADV_DONTDUMP MADV_NOCORE\n#endif\n\nstatic size_t page_size;\nstatic unsigned char canary[CANARY_SIZE];\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_memzero_as_a_weak_symbol_to_prevent_lto(void * const pnt, const size_t len)\n{\n    unsigned char *pnt_ = (unsigned char *) pnt;;\n    size_t         i = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n}\n#endif\n\nvoid\nsodium_memzero(void * const pnt, const size_t len)\n{\n#ifdef _WIN32\n    SecureZeroMemory(pnt, len);\n#elif defined(HAVE_MEMSET_S)\n    if (len > 0U && memset_s(pnt, (rsize_t) len, 0, (rsize_t) len) != 0) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#elif defined(HAVE_EXPLICIT_BZERO)\n    explicit_bzero(pnt, len);\n#elif HAVE_WEAK_SYMBOLS\n    _sodium_memzero_as_a_weak_symbol_to_prevent_lto(pnt, len);\n#else\n    volatile unsigned char *volatile pnt_ =\n        (volatile unsigned char * volatile) pnt;\n    size_t i = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n#endif\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_dummy_symbol_to_prevent_memcmp_lto(const unsigned char *b1,\n                                           const unsigned char *b2,\n                                           const size_t len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_memcmp(const void * const b1_, const void * const b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = (const unsigned char *) b1_;\n    const unsigned char *b2 = (const unsigned char *) b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char * volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char * volatile) b2_;\n#endif\n    size_t               i;\n    unsigned char        d = (unsigned char) 0U;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_memcmp_lto(b1, b2, len);\n#endif\n    for (i = 0U; i < len; i++) {\n        d |= b1[i] ^ b2[i];\n    }\n    return (1 & ((d - 1) >> 8)) - 1;\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_dummy_symbol_to_prevent_compare_lto(const unsigned char *b1,\n                                            const unsigned char *b2,\n                                            const size_t len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_compare(const unsigned char *b1_, const unsigned char *b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = b1_;\n    const unsigned char *b2 = b2_;\n#else\n    const volatile unsigned char * volatile b1 =\n        (const volatile unsigned char * volatile) b1_;\n    const volatile unsigned char * volatile b2 =\n        (const volatile unsigned char * volatile) b2_;\n#endif\n    unsigned char gt = 0U;\n    unsigned char eq = 1U;\n    size_t        i;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_compare_lto(b1, b2, len);\n#endif\n    i = len;\n    while (i != 0U) {\n        i--;\n        gt |= ((b2[i] - b1[i]) >> 8) & eq;\n        eq &= ((b2[i] ^ b1[i]) - 1) >> 8;\n    }\n    return (int) (gt + gt + eq) - 1;\n}\n\nint\nsodium_is_zero(const unsigned char *n, const size_t nlen)\n{\n    size_t        i;\n    unsigned char d = 0U;\n\n    for (i = 0U; i < nlen; i++) {\n        d |= n[i];\n    }\n    return 1 & ((d - 1) >> 8);\n}\n\nvoid\nsodium_increment(unsigned char *n, const size_t nlen)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 1U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t      t64, t64_2;\n    uint32_t      t32;\n\n    if (nlen == 12U) {\n        __asm__ __volatile__(\"xorq %[t64], %[t64] \\n\"\n                             \"xorl %[t32], %[t32] \\n\"\n                             \"stc \\n\"\n                             \"adcq %[t64], (%[out]) \\n\"\n                             \"adcl %[t32], 8(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t32] \"=&r\" (t32)\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 24U) {\n        __asm__ __volatile__(\"movq $1, %[t64] \\n\"\n                             \"xorq %[t64_2], %[t64_2] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcq %[t64_2], 8(%[out]) \\n\"\n                             \"adcq %[t64_2], 16(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t64_2] \"=&r\" (t64_2)\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 8U) {\n        __asm__ __volatile__(\"incq (%[out]) \\n\"\n                             :\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < nlen; i++) {\n        c += (uint_fast16_t) n[i];\n        n[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\nvoid\nsodium_add(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 0U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t      t64, t64_2, t64_3;\n    uint32_t      t32;\n\n    if (len == 12U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"movl 8(%[in]), %[t32] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcl %[t32], 8(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t32] \"=&r\" (t32)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 24U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"movq 8(%[in]), %[t64_2] \\n\"\n                             \"movq 16(%[in]), %[t64_3] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcq %[t64_2], 8(%[out]) \\n\"\n                             \"adcq %[t64_3], 16(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t64_2] \"=&r\"(t64_2), [t64_3] \"=&r\"(t64_3)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 8U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             : [t64] \"=&r\"(t64)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < len; i++) {\n        c += (uint_fast16_t) a[i] + (uint_fast16_t) b[i];\n        a[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\n/* Derived from original code by CodesInChaos */\nchar *\nsodium_bin2hex(char * const hex, const size_t hex_maxlen,\n               const unsigned char * const bin, const size_t bin_len)\n{\n    size_t       i = (size_t) 0U;\n    unsigned int x;\n    int          b;\n    int          c;\n\n    if (bin_len >= SIZE_MAX / 2 || hex_maxlen <= bin_len * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    while (i < bin_len) {\n        c = bin[i] & 0xf;\n        b = bin[i] >> 4;\n        x = (unsigned char) (87U + c + (((c - 10U) >> 8) & ~38U)) << 8 |\n            (unsigned char) (87U + b + (((b - 10U) >> 8) & ~38U));\n        hex[i * 2U] = (char) x;\n        x >>= 8;\n        hex[i * 2U + 1U] = (char) x;\n        i++;\n    }\n    hex[i * 2U] = 0U;\n\n    return hex;\n}\n\nint\nsodium_hex2bin(unsigned char * const bin, const size_t bin_maxlen,\n               const char * const hex, const size_t hex_len,\n               const char * const ignore, size_t * const bin_len,\n               const char ** const hex_end)\n{\n    size_t        bin_pos = (size_t) 0U;\n    size_t        hex_pos = (size_t) 0U;\n    int           ret = 0;\n    unsigned char c;\n    unsigned char c_acc = 0U;\n    unsigned char c_alpha0, c_alpha;\n    unsigned char c_num0, c_num;\n    unsigned char c_val;\n    unsigned char state = 0U;\n\n    while (hex_pos < hex_len) {\n        c = (unsigned char) hex[hex_pos];\n        c_num = c ^ 48U;\n        c_num0 = (c_num - 10U) >> 8;\n        c_alpha = (c & ~32U) - 55U;\n        c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;\n        if ((c_num0 | c_alpha0) == 0U) {\n            if (ignore != NULL && state == 0U && strchr(ignore, c) != NULL) {\n                hex_pos++;\n                continue;\n            }\n            break;\n        }\n        c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);\n        if (bin_pos >= bin_maxlen) {\n            ret = -1;\n            errno = ERANGE;\n            break;\n        }\n        if (state == 0U) {\n            c_acc = c_val * 16U;\n        } else {\n            bin[bin_pos++] = c_acc | c_val;\n        }\n        state = ~state;\n        hex_pos++;\n    }\n    if (state != 0U) {\n        hex_pos--;\n    }\n    if (hex_end != NULL) {\n        *hex_end = &hex[hex_pos];\n    }\n    if (bin_len != NULL) {\n        *bin_len = bin_pos;\n    }\n    return ret;\n}\n\nint\n_sodium_alloc_init(void)\n{\n#ifdef HAVE_ALIGNED_MALLOC\n# if defined(_SC_PAGESIZE)\n    long page_size_ = sysconf(_SC_PAGESIZE);\n    if (page_size_ > 0L) {\n        page_size = (size_t) page_size_;\n    }\n# elif defined(WINAPI_DESKTOP)\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    page_size = (size_t) si.dwPageSize;\n# endif\n    if (page_size < CANARY_SIZE || page_size < sizeof(size_t)) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#endif\n    randombytes_buf(canary, sizeof canary);\n\n    return 0;\n}\n\nint\nsodium_mlock(void * const addr, const size_t len)\n{\n#if defined(MADV_DONTDUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DONTDUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return mlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualLock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nint\nsodium_munlock(void * const addr, const size_t len)\n{\n    sodium_memzero(addr, len);\n#if defined(MADV_DODUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DODUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return munlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualUnlock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_noaccess(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_NONE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_NOACCESS, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readonly(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READONLY, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readwrite(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ | PROT_WRITE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READWRITE, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\n#ifdef HAVE_ALIGNED_MALLOC\n\n__attribute__ ((noreturn)) static void\n_out_of_bounds(void)\n{\n# ifdef SIGSEGV\n    raise(SIGSEGV);\n# elif defined(SIGKILL)\n    raise(SIGKILL);\n# endif\n    abort();\n} /* LCOV_EXCL_LINE */\n\nstatic inline size_t\n_page_round(const size_t size)\n{\n    const size_t page_mask = page_size - 1U;\n\n    return (size + page_mask) & ~page_mask;\n}\n\nstatic __attribute__ ((malloc)) unsigned char *\n_alloc_aligned(const size_t size)\n{\n    void *ptr;\n\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    if ((ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,\n                    MAP_ANON | MAP_PRIVATE | MAP_NOCORE, -1, 0)) == MAP_FAILED) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    } /* LCOV_EXCL_LINE */\n# elif defined(HAVE_POSIX_MEMALIGN)\n    if (posix_memalign(&ptr, page_size, size) != 0) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    } /* LCOV_EXCL_LINE */\n# elif defined(WINAPI_DESKTOP)\n    ptr = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n# else\n#  error Bug\n# endif\n    return (unsigned char *) ptr;\n}\n\nstatic void\n_free_aligned(unsigned char * const ptr, const size_t size)\n{\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    (void) munmap(ptr, size);\n# elif defined(HAVE_POSIX_MEMALIGN)\n    free(ptr);\n# elif defined(WINAPI_DESKTOP)\n    VirtualFree(ptr, 0U, MEM_RELEASE);\n# else\n#  error Bug\n# endif\n}\n\nstatic unsigned char *\n_unprotected_ptr_from_user_ptr(void * const ptr)\n{\n    uintptr_t      unprotected_ptr_u;\n    unsigned char *canary_ptr;\n    size_t         page_mask;\n\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    page_mask = page_size - 1U;\n    unprotected_ptr_u = ((uintptr_t) canary_ptr & (uintptr_t) ~page_mask);\n    if (unprotected_ptr_u <= page_size * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    return (unsigned char *) unprotected_ptr_u;\n}\n\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_ALIGNED_MALLOC\nstatic __attribute__ ((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    return malloc(size > (size_t) 0U ? size : (size_t) 1U);\n}\n#else\nstatic __attribute__ ((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    void          *user_ptr;\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         size_with_canary;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (size >= (size_t) SIZE_MAX - page_size * 4U) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    if (page_size <= sizeof canary || page_size < sizeof unprotected_size) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    size_with_canary = (sizeof canary) + size;\n    unprotected_size = _page_round(size_with_canary);\n    total_size = page_size + page_size + unprotected_size + page_size;\n    if ((base_ptr = _alloc_aligned(total_size)) == NULL) {\n        return NULL; /* LCOV_EXCL_LINE */\n    }\n    unprotected_ptr = base_ptr + page_size * 2U;\n    _mprotect_noaccess(base_ptr + page_size, page_size);\n# ifndef HAVE_PAGE_PROTECTION\n    memcpy(unprotected_ptr + unprotected_size, canary, sizeof canary);\n# endif\n    _mprotect_noaccess(unprotected_ptr + unprotected_size, page_size);\n    sodium_mlock(unprotected_ptr, unprotected_size);\n    canary_ptr = unprotected_ptr + _page_round(size_with_canary) -\n        size_with_canary;\n    user_ptr = canary_ptr + sizeof canary;\n    memcpy(canary_ptr, canary, sizeof canary);\n    memcpy(base_ptr, &unprotected_size, sizeof unprotected_size);\n    _mprotect_readonly(base_ptr, page_size);\n    assert(_unprotected_ptr_from_user_ptr(user_ptr) == unprotected_ptr);\n\n    return user_ptr;\n}\n#endif /* !HAVE_ALIGNED_MALLOC */\n\n__attribute__ ((malloc)) void *\nsodium_malloc(const size_t size)\n{\n    void *ptr;\n\n    if ((ptr = _sodium_malloc(size)) == NULL) {\n        return NULL;\n    }\n    memset(ptr, (int) GARBAGE_VALUE, size);\n\n    return ptr;\n}\n\n__attribute__ ((malloc)) void *\nsodium_allocarray(size_t count, size_t size)\n{\n    size_t total_size;\n\n    if (count > (size_t) 0U && size >= (size_t) SIZE_MAX / count) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    total_size = count * size;\n\n    return sodium_malloc(total_size);\n}\n\n#ifndef HAVE_ALIGNED_MALLOC\nvoid\nsodium_free(void *ptr)\n{\n    free(ptr);\n}\n#else\nvoid\nsodium_free(void *ptr)\n{\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (ptr == NULL) {\n        return;\n    }\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n    total_size = page_size + page_size + unprotected_size + page_size;\n    _mprotect_readwrite(base_ptr, total_size);\n    if (sodium_memcmp(canary_ptr, canary, sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# ifndef HAVE_PAGE_PROTECTION\n    if (sodium_memcmp(unprotected_ptr + unprotected_size,\n                      canary, sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# endif\n    sodium_munlock(unprotected_ptr, unprotected_size);\n    _free_aligned(base_ptr, total_size);\n}\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_PAGE_PROTECTION\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    (void) ptr;\n    (void) cb;\n    errno = ENOSYS;\n    return -1;\n}\n#else\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    unsigned char *base_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         unprotected_size;\n\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n\n    return cb(unprotected_ptr, unprotected_size);\n}\n#endif\n\nint\nsodium_mprotect_noaccess(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_noaccess);\n}\n\nint\nsodium_mprotect_readonly(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readonly);\n}\n\nint\nsodium_mprotect_readwrite(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readwrite);\n}\n","\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"randombytes_sysrandom.h\"\n\n#ifdef __native_client__\n# include \"randombytes_nativeclient.h\"\n#endif\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifdef __EMSCRIPTEN__\n# define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n#else\n# ifdef __native_client__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n# else\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\n/*\n * randombytes_uniform() derives from OpenBSD's arc4random_uniform()\n * Copyright (c) 2008, Damien Miller <djm@openbsd.org>\n */\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (uint32_t) (-upper_bound % upper_bound);\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","#include \"crypto_stream_chacha20.h\"\n#include \"stream_chacha20.h\"\n#include \"runtime.h\"\n#include \"ref/stream_chacha20_ref.h\"\n#if (defined(HAVE_EMMINTRIN_H) && defined(HAVE_TMMINTRIN_H) && defined(__GNUC__))\n# include \"vec/stream_chacha20_vec.h\"\n#endif\n\nstatic const crypto_stream_chacha20_implementation *implementation =\n    &crypto_stream_chacha20_ref_implementation;\n\nsize_t\ncrypto_stream_chacha20_keybytes(void) {\n    return crypto_stream_chacha20_KEYBYTES;\n}\n\nsize_t\ncrypto_stream_chacha20_noncebytes(void) {\n    return crypto_stream_chacha20_NONCEBYTES;\n}\n\nsize_t\ncrypto_stream_chacha20_ietf_noncebytes(void) {\n    return crypto_stream_chacha20_IETF_NONCEBYTES;\n}\n\nint\ncrypto_stream_chacha20(unsigned char *c, unsigned long long clen,\n                       const unsigned char *n, const unsigned char *k)\n{\n    return implementation->stream(c, clen, n, k);\n}\n\nint\ncrypto_stream_chacha20_ietf(unsigned char *c, unsigned long long clen,\n                            const unsigned char *n, const unsigned char *k)\n{\n    return implementation->stream_ietf(c, clen, n, k);\n}\n\nint\ncrypto_stream_chacha20_xor_ic(unsigned char *c, const unsigned char *m,\n                              unsigned long long mlen,\n                              const unsigned char *n, uint64_t ic,\n                              const unsigned char *k)\n{\n    return implementation->stream_xor_ic(c, m, mlen, n, ic, k);\n}\n\nint\ncrypto_stream_chacha20_ietf_xor_ic(unsigned char *c, const unsigned char *m,\n                                   unsigned long long mlen,\n                                   const unsigned char *n, uint32_t ic,\n                                   const unsigned char *k)\n{\n    return implementation->stream_ietf_xor_ic(c, m, mlen, n, ic, k);\n}\n\nint\ncrypto_stream_chacha20_xor(unsigned char *c, const unsigned char *m,\n                           unsigned long long mlen, const unsigned char *n,\n                           const unsigned char *k)\n{\n    return implementation->stream_xor_ic(c, m, mlen, n, 0U, k);\n}\n\nint\ncrypto_stream_chacha20_ietf_xor(unsigned char *c, const unsigned char *m,\n                                unsigned long long mlen, const unsigned char *n,\n                                const unsigned char *k)\n{\n    return implementation->stream_ietf_xor_ic(c, m, mlen, n, 0U, k);\n}\n\nint\n_crypto_stream_chacha20_pick_best_implementation(void)\n{\n    implementation = &crypto_stream_chacha20_ref_implementation;\n#if (defined(HAVE_EMMINTRIN_H) && defined(HAVE_TMMINTRIN_H) && defined(__GNUC__))\n    if (sodium_runtime_has_ssse3()) {\n        implementation = &crypto_stream_chacha20_vec_implementation;\n    }\n#endif\n    return 0;\n}\n","\n/*\n chacha-merged.c version 20080118\n D. J. Bernstein\n Public domain.\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"utils.h\"\n#include \"crypto_stream_chacha20.h\"\n#include \"stream_chacha20_ref.h\"\n#include \"../stream_chacha20.h\"\n#include \"private/common.h\"\n\nstruct chacha_ctx {\n    uint32_t input[16];\n};\n\ntypedef uint8_t  u8;\ntypedef uint32_t u32;\n\ntypedef struct chacha_ctx chacha_ctx;\n\n#define U8C(v) (v##U)\n#define U32C(v) (v##U)\n\n#define U8V(v) ((u8)(v) & U8C(0xFF))\n#define U32V(v) ((u32)(v) & U32C(0xFFFFFFFF))\n\n#define ROTL32(v, n) \\\n  (U32V((v) << (n)) | ((v) >> (32 - (n))))\n\n#define ROTATE(v,c) (ROTL32(v,c))\n#define XOR(v,w) ((v) ^ (w))\n#define PLUS(v,w) (U32V((v) + (w)))\n#define PLUSONE(v) (PLUS((v),1))\n\n#define QUARTERROUND(a,b,c,d) \\\n  a = PLUS(a,b); d = ROTATE(XOR(d,a),16); \\\n  c = PLUS(c,d); b = ROTATE(XOR(b,c),12); \\\n  a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); \\\n  c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);\n\nstatic void\nchacha_keysetup(chacha_ctx *ctx, const u8 *k)\n{\n    ctx->input[0]  = U32C(0x61707865);\n    ctx->input[1]  = U32C(0x3320646e);\n    ctx->input[2]  = U32C(0x79622d32);\n    ctx->input[3]  = U32C(0x6b206574);\n    ctx->input[4]  = LOAD32_LE(k +  0);\n    ctx->input[5]  = LOAD32_LE(k +  4);\n    ctx->input[6]  = LOAD32_LE(k +  8);\n    ctx->input[7]  = LOAD32_LE(k + 12);\n    ctx->input[8]  = LOAD32_LE(k + 16);\n    ctx->input[9]  = LOAD32_LE(k + 20);\n    ctx->input[10] = LOAD32_LE(k + 24);\n    ctx->input[11] = LOAD32_LE(k + 28);\n}\n\nstatic void\nchacha_ivsetup(chacha_ctx *ctx, const u8 *iv, const u8 *counter)\n{\n    ctx->input[12] = counter == NULL ? 0 : LOAD32_LE(counter + 0);\n    ctx->input[13] = counter == NULL ? 0 : LOAD32_LE(counter + 4);\n    ctx->input[14] = LOAD32_LE(iv + 0);\n    ctx->input[15] = LOAD32_LE(iv + 4);\n}\n\nstatic void\nchacha_ietf_ivsetup(chacha_ctx *ctx, const u8 *iv, const u8 *counter)\n{\n    ctx->input[12] = counter == NULL ? 0 : LOAD32_LE(counter);\n    ctx->input[13] = LOAD32_LE(iv + 0);\n    ctx->input[14] = LOAD32_LE(iv + 4);\n    ctx->input[15] = LOAD32_LE(iv + 8);\n}\n\nstatic void\nchacha_encrypt_bytes(chacha_ctx *ctx, const u8 *m, u8 *c, unsigned long long bytes)\n{\n    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n    u8 *ctarget = NULL;\n    u8 tmp[64];\n    unsigned int i;\n\n    if (!bytes) {\n        return; /* LCOV_EXCL_LINE */\n    }\n    if (bytes > 64ULL * (1ULL << 32) - 64ULL) {\n        abort();\n    }\n    j0 = ctx->input[0];\n    j1 = ctx->input[1];\n    j2 = ctx->input[2];\n    j3 = ctx->input[3];\n    j4 = ctx->input[4];\n    j5 = ctx->input[5];\n    j6 = ctx->input[6];\n    j7 = ctx->input[7];\n    j8 = ctx->input[8];\n    j9 = ctx->input[9];\n    j10 = ctx->input[10];\n    j11 = ctx->input[11];\n    j12 = ctx->input[12];\n    j13 = ctx->input[13];\n    j14 = ctx->input[14];\n    j15 = ctx->input[15];\n\n    for (;;) {\n        if (bytes < 64) {\n            memset(tmp, 0, 64);\n            for (i = 0; i < bytes; ++i) {\n                tmp[i] = m[i];\n            }\n            m = tmp;\n            ctarget = c;\n            c = tmp;\n        }\n        x0 = j0;\n        x1 = j1;\n        x2 = j2;\n        x3 = j3;\n        x4 = j4;\n        x5 = j5;\n        x6 = j6;\n        x7 = j7;\n        x8 = j8;\n        x9 = j9;\n        x10 = j10;\n        x11 = j11;\n        x12 = j12;\n        x13 = j13;\n        x14 = j14;\n        x15 = j15;\n        for (i = 20; i > 0; i -= 2) {\n            QUARTERROUND(x0, x4, x8, x12)\n            QUARTERROUND(x1, x5, x9, x13)\n            QUARTERROUND(x2, x6, x10, x14)\n            QUARTERROUND(x3, x7, x11, x15)\n            QUARTERROUND(x0, x5, x10, x15)\n            QUARTERROUND(x1, x6, x11, x12)\n            QUARTERROUND(x2, x7, x8, x13)\n            QUARTERROUND(x3, x4, x9, x14)\n        }\n        x0 = PLUS(x0, j0);\n        x1 = PLUS(x1, j1);\n        x2 = PLUS(x2, j2);\n        x3 = PLUS(x3, j3);\n        x4 = PLUS(x4, j4);\n        x5 = PLUS(x5, j5);\n        x6 = PLUS(x6, j6);\n        x7 = PLUS(x7, j7);\n        x8 = PLUS(x8, j8);\n        x9 = PLUS(x9, j9);\n        x10 = PLUS(x10, j10);\n        x11 = PLUS(x11, j11);\n        x12 = PLUS(x12, j12);\n        x13 = PLUS(x13, j13);\n        x14 = PLUS(x14, j14);\n        x15 = PLUS(x15, j15);\n\n        x0 = XOR(x0, LOAD32_LE(m + 0));\n        x1 = XOR(x1, LOAD32_LE(m + 4));\n        x2 = XOR(x2, LOAD32_LE(m + 8));\n        x3 = XOR(x3, LOAD32_LE(m + 12));\n        x4 = XOR(x4, LOAD32_LE(m + 16));\n        x5 = XOR(x5, LOAD32_LE(m + 20));\n        x6 = XOR(x6, LOAD32_LE(m + 24));\n        x7 = XOR(x7, LOAD32_LE(m + 28));\n        x8 = XOR(x8, LOAD32_LE(m + 32));\n        x9 = XOR(x9, LOAD32_LE(m + 36));\n        x10 = XOR(x10, LOAD32_LE(m + 40));\n        x11 = XOR(x11, LOAD32_LE(m + 44));\n        x12 = XOR(x12, LOAD32_LE(m + 48));\n        x13 = XOR(x13, LOAD32_LE(m + 52));\n        x14 = XOR(x14, LOAD32_LE(m + 56));\n        x15 = XOR(x15, LOAD32_LE(m + 60));\n\n        j12 = PLUSONE(j12);\n        /* LCOV_EXCL_START */\n        if (!j12) {\n            j13 = PLUSONE(j13);\n        }\n        /* LCOV_EXCL_STOP */\n\n        STORE32_LE(c + 0, x0);\n        STORE32_LE(c + 4, x1);\n        STORE32_LE(c + 8, x2);\n        STORE32_LE(c + 12, x3);\n        STORE32_LE(c + 16, x4);\n        STORE32_LE(c + 20, x5);\n        STORE32_LE(c + 24, x6);\n        STORE32_LE(c + 28, x7);\n        STORE32_LE(c + 32, x8);\n        STORE32_LE(c + 36, x9);\n        STORE32_LE(c + 40, x10);\n        STORE32_LE(c + 44, x11);\n        STORE32_LE(c + 48, x12);\n        STORE32_LE(c + 52, x13);\n        STORE32_LE(c + 56, x14);\n        STORE32_LE(c + 60, x15);\n\n        if (bytes <= 64) {\n            if (bytes < 64) {\n                for (i = 0; i < (unsigned int) bytes; ++i) {\n                    ctarget[i] = c[i]; /* ctarget cannot be NULL */\n                }\n            }\n            ctx->input[12] = j12;\n            ctx->input[13] = j13;\n            return;\n        }\n        bytes -= 64;\n        c += 64;\n        m += 64;\n    }\n}\n\nstatic int\nstream_ref(unsigned char *c, unsigned long long clen,\n           const unsigned char *n, const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!clen) {\n        return 0;\n    }\n    (void) sizeof(int[crypto_stream_chacha20_KEYBYTES == 256 / 8 ? 1 : -1]);\n    chacha_keysetup(&ctx, k);\n    chacha_ivsetup(&ctx, n, NULL);\n    memset(c, 0, clen);\n    chacha_encrypt_bytes(&ctx, c, c, clen);\n    sodium_memzero(&ctx, sizeof ctx);\n\n    return 0;\n}\n\nstatic int\nstream_ietf_ref(unsigned char *c, unsigned long long clen,\n                const unsigned char *n, const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!clen) {\n        return 0;\n    }\n    (void) sizeof(int[crypto_stream_chacha20_KEYBYTES == 256 / 8 ? 1 : -1]);\n    chacha_keysetup(&ctx, k);\n    chacha_ietf_ivsetup(&ctx, n, NULL);\n    memset(c, 0, clen);\n    chacha_encrypt_bytes(&ctx, c, c, clen);\n    sodium_memzero(&ctx, sizeof ctx);\n\n    return 0;\n}\n\nstatic int\nstream_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                  unsigned long long mlen,\n                  const unsigned char *n, uint64_t ic,\n                  const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n    uint8_t           ic_bytes[8];\n    uint32_t          ic_high;\n    uint32_t          ic_low;\n\n    if (!mlen) {\n        return 0;\n    }\n    ic_high = U32V(ic >> 32);\n    ic_low = U32V(ic);\n    STORE32_LE(&ic_bytes[0], ic_low);\n    STORE32_LE(&ic_bytes[4], ic_high);\n    chacha_keysetup(&ctx, k);\n    chacha_ivsetup(&ctx, n, ic_bytes);\n    chacha_encrypt_bytes(&ctx, m, c, mlen);\n    sodium_memzero(&ctx, sizeof ctx);\n\n    return 0;\n}\n\nstatic int\nstream_ietf_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                       unsigned long long mlen,\n                       const unsigned char *n, uint32_t ic,\n                       const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n    uint8_t           ic_bytes[4];\n\n    if (!mlen) {\n        return 0;\n    }\n    STORE32_LE(ic_bytes, ic);\n    chacha_keysetup(&ctx, k);\n    chacha_ietf_ivsetup(&ctx, n, ic_bytes);\n    chacha_encrypt_bytes(&ctx, m, c, mlen);\n    sodium_memzero(&ctx, sizeof ctx);\n\n    return 0;\n}\n\nstruct crypto_stream_chacha20_implementation\ncrypto_stream_chacha20_ref_implementation = {\n    SODIUM_C99(.stream =) stream_ref,\n    SODIUM_C99(.stream_ietf =) stream_ietf_ref,\n    SODIUM_C99(.stream_xor_ic =) stream_ref_xor_ic,\n    SODIUM_C99(.stream_ietf_xor_ic =) stream_ietf_ref_xor_ic\n};\n","#ifndef common_H\n#define common_H 1\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define LOAD64_LE(SRC) load64_le(SRC)\nstatic inline uint64_t\nload64_le(const uint8_t src[8])\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n    uint64_t w;\n    memcpy(&w, src, sizeof w);\n    return w;\n#else\n    uint64_t w = (uint64_t) src[0];\n    w |= (uint64_t) src[1] <<  8;\n    w |= (uint64_t) src[2] << 16;\n    w |= (uint64_t) src[3] << 24;\n    w |= (uint64_t) src[4] << 32;\n    w |= (uint64_t) src[5] << 40;\n    w |= (uint64_t) src[6] << 48;\n    w |= (uint64_t) src[7] << 56;\n    return w;\n#endif\n}\n\n#define STORE64_LE(DST, W) store64_le((DST), (W))\nstatic inline void\nstore64_le(uint8_t dst[8], uint64_t w)\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n    memcpy(dst, &w, sizeof w);\n#else\n    dst[0] = (uint8_t) w; w >>= 8;\n    dst[1] = (uint8_t) w; w >>= 8;\n    dst[2] = (uint8_t) w; w >>= 8;\n    dst[3] = (uint8_t) w; w >>= 8;\n    dst[4] = (uint8_t) w; w >>= 8;\n    dst[5] = (uint8_t) w; w >>= 8;\n    dst[6] = (uint8_t) w; w >>= 8;\n    dst[7] = (uint8_t) w;\n#endif\n}\n\n#define LOAD32_LE(SRC) load32_le(SRC)\nstatic inline uint32_t\nload32_le(const uint8_t src[4])\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n    uint32_t w;\n    memcpy(&w, src, sizeof w);\n    return w;\n#else\n    uint32_t w = (uint32_t) src[0];\n    w |= (uint32_t) src[1] <<  8;\n    w |= (uint32_t) src[2] << 16;\n    w |= (uint32_t) src[3] << 24;\n    return w;\n#endif\n}\n\n#define STORE32_LE(DST, W) store32_le((DST), (W))\nstatic inline void\nstore32_le(uint8_t dst[4], uint32_t w)\n{\n#ifdef NATIVE_LITTLE_ENDIAN\n    memcpy(dst, &w, sizeof w);\n#else\n    dst[0] = (uint8_t) w; w >>= 8;\n    dst[1] = (uint8_t) w; w >>= 8;\n    dst[2] = (uint8_t) w; w >>= 8;\n    dst[3] = (uint8_t) w;\n#endif\n}\n\n/* ----- */\n\n#define LOAD64_BE(SRC) load64_be(SRC)\nstatic inline uint64_t\nload64_be(const uint8_t src[8])\n{\n#ifdef NATIVE_BIG_ENDIAN\n    uint64_t w;\n    memcpy(&w, src, sizeof w);\n    return w;\n#else\n    uint64_t w = (uint64_t) src[7];\n    w |= (uint64_t) src[6] <<  8;\n    w |= (uint64_t) src[5] << 16;\n    w |= (uint64_t) src[4] << 24;\n    w |= (uint64_t) src[3] << 32;\n    w |= (uint64_t) src[2] << 40;\n    w |= (uint64_t) src[1] << 48;\n    w |= (uint64_t) src[0] << 56;\n    return w;\n#endif\n}\n\n#define LOAD32_BE(SRC) load32_be(SRC)\nstatic inline uint32_t\nload32_be(const uint8_t src[4])\n{\n#ifdef NATIVE_BIG_ENDIAN\n    uint32_t w;\n    memcpy(&w, src, sizeof w);\n    return w;\n#else\n    uint32_t w = (uint32_t) src[3];\n    w |= (uint32_t) src[2] <<  8;\n    w |= (uint32_t) src[1] << 16;\n    w |= (uint32_t) src[0] << 24;\n    return w;\n#endif\n}\n\n#define STORE64_BE(DST, W) store64_be((DST), (W))\nstatic inline void\nstore64_be(uint8_t dst[8], uint64_t w)\n{\n#ifdef NATIVE_BIG_ENDIAN\n    memcpy(dst, &w, sizeof w);\n#else\n    dst[7] = (uint8_t) w; w >>= 8;\n    dst[6] = (uint8_t) w; w >>= 8;\n    dst[5] = (uint8_t) w; w >>= 8;\n    dst[4] = (uint8_t) w; w >>= 8;\n    dst[3] = (uint8_t) w; w >>= 8;\n    dst[2] = (uint8_t) w; w >>= 8;\n    dst[1] = (uint8_t) w; w >>= 8;\n    dst[0] = (uint8_t) w;\n#endif\n}\n\n#define STORE32_BE(DST, W) store32_be((DST), (W))\nstatic inline void\nstore32_be(uint8_t dst[4], uint32_t w)\n{\n#ifdef NATIVE_BIG_ENDIAN\n    memcpy(dst, &w, sizeof w);\n#else\n    dst[3] = (uint8_t) w; w >>= 8;\n    dst[2] = (uint8_t) w; w >>= 8;\n    dst[1] = (uint8_t) w; w >>= 8;\n    dst[0] = (uint8_t) w;\n#endif\n}\n\n#endif\n","/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: NTT functions and other polynomial operations\r\n*\r\n*****************************************************************************************/\r\n\r\n#include \"../LatticeCrypto_priv.h\"\r\n\r\nconst uint32_t mask12 = ((uint64_t)1 << 12) - 1;\r\n\r\n    \r\nint32_t reduce12289(int64_t a)\r\n{ // Reduction modulo q\r\n    int32_t c0, c1;\r\n   \r\n    c0 = (int32_t)(a & mask12);\r\n    c1 = (int32_t)(a >> 12);\r\n \r\n    return (3*c0 - c1);\r\n}\r\n\r\n    \r\nint32_t reduce12289_2x(int64_t a)\r\n{ // Two merged reductions modulo q\r\n    int32_t c0, c1, c2;\r\n   \r\n    c0 = (int32_t)(a & mask12);\r\n    c1 = (int32_t)((a >> 12) & mask12);\r\n    c2 = (int32_t)(a >> 24);\r\n \r\n    return (9*c0 - 3*c1 + c2);\r\n}\r\n\r\n\r\nvoid NTT_CT_std2rev_12289(int32_t* a, const int32_t* psi_rev, unsigned int N)\r\n{ // Forward NTT\r\n    unsigned int m, i, j, j1, j2, k = N;\r\n    int32_t S, U, V;\r\n\r\n    for (m = 1; m < 128; m = 2*m) {\r\n        k = k >> 1;\r\n        for (i = 0; i < m; i++) {\r\n            j1 = 2*i*k;\r\n            j2 = j1+k-1;\r\n            S = psi_rev[m+i];\r\n            for (j = j1; j <= j2; j++) { \r\n                U = a[j]; \r\n                V = reduce12289((int64_t)a[j+k]*S);\r\n                a[j] = U+V;\r\n                a[j+k] = U-V;\r\n            }\r\n        }\r\n    }\r\n\r\n    k = 4;\r\n    for (i = 0; i < 128; i++) {\r\n        j1 = 8*i;\r\n        j2 = j1+3;\r\n        S = psi_rev[i+128];\r\n        for (j = j1; j <= j2; j++) {\r\n            U = reduce12289((int64_t)a[j]);\r\n            V = reduce12289_2x((int64_t)a[j+4]*S);\r\n            a[j] = U+V;\r\n            a[j+4] = U-V;\r\n        }\r\n    }\r\n\r\n    for (m = 256; m < N; m = 2*m) {\r\n        k = k >> 1;\r\n        for (i = 0; i < m; i++) {\r\n            j1 = 2*i*k;\r\n            j2 = j1+k-1;\r\n            S = psi_rev[m+i];\r\n            for (j = j1; j <= j2; j++) { \r\n                U = a[j]; \r\n                V = reduce12289((int64_t)a[j+k]*S); \r\n                a[j] = U+V;\r\n                a[j+k] = U-V;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\n\r\nvoid INTT_GS_rev2std_12289(int32_t* a, const int32_t* omegainv_rev, const int32_t omegainv1N_rev, const int32_t Ninv, unsigned int N)\r\n{ // Inverse NTT\r\n    unsigned int m, h, i, j, j1, j2, k = 1;\r\n    int32_t S, U, V;\r\n    int64_t temp;\r\n\r\n    for (m = N; m > 2; m >>= 1) {\r\n        j1 = 0;\r\n        h = m >> 1;\r\n        for (i = 0; i < h; i++) {\r\n            j2 = j1+k-1;\r\n            S = omegainv_rev[h+i];\r\n            for (j = j1; j <= j2; j++) {\r\n                U = a[j];\r\n                V = a[j+k];\r\n                a[j] = U+V;\r\n                temp = (int64_t)(U-V)*S;\r\n                if (m == 32) {\r\n                    a[j] = reduce12289((int64_t)a[j]);\r\n                    a[j+k] = reduce12289_2x(temp);\r\n                } else {\r\n                    a[j+k] = reduce12289(temp);\r\n                }\r\n             }\r\n             j1 = j1+2*k;\r\n        }\r\n        k = 2*k;\r\n    }\r\n    for (j = 0; j < k; j++) {\r\n        U = a[j];\r\n        V = a[j+k];\r\n        a[j] = reduce12289((int64_t)(U+V)*Ninv);\r\n        a[j+k] = reduce12289((int64_t)(U-V)*omegainv1N_rev);\r\n    }\r\n    return;\r\n}\r\n\r\n\r\nvoid two_reduce12289(int32_t* a, unsigned int N)\r\n{ // Two consecutive reductions modulo q\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        a[i] = reduce12289((int64_t)a[i]);\r\n        a[i] = reduce12289((int64_t)a[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid pmul(int32_t* a, int32_t* b, int32_t* c, unsigned int N)\r\n{ // Component-wise multiplication\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        c[i] = reduce12289((int64_t)a[i]*b[i]);\r\n        c[i] = reduce12289((int64_t)c[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid pmuladd(int32_t* a, int32_t* b, int32_t* c, int32_t* d, unsigned int N)\r\n{ // Component-wise multiplication and addition\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        d[i] = reduce12289((int64_t)a[i]*b[i] + c[i]);\r\n        d[i] = reduce12289((int64_t)d[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid smul(int32_t* a, int32_t scalar, unsigned int N)\r\n{ // Component-wise multiplication with scalar\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        a[i] = a[i]*scalar;\r\n    }\r\n}\r\n\r\n\r\nvoid correction(int32_t* a, int32_t p, unsigned int N)\r\n{ // Correction modulo q \r\n    unsigned int i; \r\n    int32_t mask;\r\n\r\n    for (i = 0; i < N; i++) {\r\n        mask = a[i] >> (4*sizeof(int32_t) - 1);\r\n        a[i] += (p & mask) - p;\r\n        mask = a[i] >> (4*sizeof(int32_t) - 1);\r\n        a[i] += (p & mask);\r\n    }\r\n}\r\n","#include <stdlib.h>\n/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: Ring-LWE key exchange\r\n*           The implementation is based on the instantiation of Peikert's key exchange [1]\r\n*           due to Alkim, Ducas, Poppelmann and Schwabe [2].\r\n*\r\n* [1] C. Peikert, \"Lattice cryptography for the internet\", in Post-Quantum Cryptography - \r\n*     6th International Workshop (PQCrypto 2014), LNCS 8772, pp. 197-219. Springer, 2014.\r\n* [2] E. Alkim, L. Ducas, T. P�ppelmann and P. Schwabe, \"Post-quantum key exchange - a new \r\n*     hope\", IACR Cryptology ePrint Archive, Report 2015/1092, 2015.\r\n*\r\n******************************************************************************************/ \r\n\r\n#include \"LatticeCrypto_priv.h\"\r\n#include <malloc.h>\r\n\r\nextern const int32_t psi_rev_ntt1024_12289[1024];           \r\nextern const int32_t omegainv_rev_ntt1024_12289[1024];\r\nextern const int32_t omegainv10N_rev_ntt1024_12289;\r\nextern const int32_t Ninv11_ntt1024_12289;\r\n\r\n\r\n__inline void clear_words(void* mem, digit_t nwords)\r\n{ // Clear digits from memory. \"nwords\" indicates the number of digits to be zeroed.\r\n  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.\r\n    unsigned int i;\r\n    volatile digit_t *v = mem; \r\n\r\n    for (i = 0; i < nwords; i++) {\r\n        v[i] = 0;\r\n    }\r\n}\r\n\r\n\r\nCRYPTO_STATUS LatticeCrypto_initialize(PLatticeCryptoStruct pLatticeCrypto, RandomBytes RandomBytesFunction, ExtendableOutput ExtendableOutputFunction, StreamOutput StreamOutputFunction)\r\n{ // Initialize structure pLatticeCrypto with user-provided functions: RandomBytesFunction, ExtendableOutputFunction and StreamOutputFunction.\r\n\r\n    pLatticeCrypto->RandomBytesFunction = RandomBytesFunction;\r\n    pLatticeCrypto->ExtendableOutputFunction = ExtendableOutputFunction;\r\n    pLatticeCrypto->StreamOutputFunction = StreamOutputFunction;\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nPLatticeCryptoStruct LatticeCrypto_allocate()\r\n{ // Dynamic allocation of memory for LatticeCrypto structure. It should be called before initialization with LatticeCrypto_initialize(). \r\n  // Returns NULL on error.\r\n    PLatticeCryptoStruct LatticeCrypto = NULL;\r\n\r\n    LatticeCrypto = (PLatticeCryptoStruct)calloc(1, sizeof(LatticeCryptoStruct));\r\n\r\n    if (LatticeCrypto == NULL) {\r\n        return NULL;\r\n    }\r\n    return LatticeCrypto;\r\n}\r\n\r\n\r\nconst char* LatticeCrypto_get_error_message(CRYPTO_STATUS Status)\r\n{ // Output error/success message for a given CRYPTO_STATUS\r\n    struct error_mapping {\r\n        unsigned int index;\r\n        char*        string;\r\n    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {\r\n        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},\r\n        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},\r\n        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},\r\n        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},\r\n        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},\r\n        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},\r\n        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},\r\n        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},\r\n        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}\r\n    };\r\n\r\n    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {\r\n        return \"Unrecognized CRYPTO_STATUS\";\r\n    } else {\r\n        return mapping[Status].string;\r\n    }\r\n};\r\n\r\n\r\nvoid encode_A(const uint32_t* pk, const unsigned char* seed, unsigned char* m)\r\n{ // Alice's message encoding\r\n    unsigned int i = 0, j;\r\n        \r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    for (j = 0; j < 1024; j += 4) {        \r\n        m[i]   = (unsigned char)(pk[j] & 0xFF);\r\n        m[i+1] = (unsigned char)((pk[j] >> 8) | ((pk[j+1] & 0x03) << 6));\r\n        m[i+2] = (unsigned char)((pk[j+1] >> 2) & 0xFF);\r\n        m[i+3] = (unsigned char)((pk[j+1] >> 10) | ((pk[j+2] & 0x0F) << 4));\r\n        m[i+4] = (unsigned char)((pk[j+2] >> 4) & 0xFF);\r\n        m[i+5] = (unsigned char)((pk[j+2] >> 12) | ((pk[j+3] & 0x3F) << 2));\r\n        m[i+6] = (unsigned char)(pk[j+3] >> 6);\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    encode_asm(pk, m);\r\n    i = 1792;\r\n#endif\r\n\r\n    for (j = 0; j < 32; j++) {\r\n        m[i+j] = seed[j];\r\n    }\r\n}\r\n\r\n\r\nvoid decode_A(const unsigned char* m, uint32_t *pk, unsigned char* seed)\r\n{ // Alice's message decoding \r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    for (j = 0; j < 1024; j += 4) {        \r\n        pk[j]   = ((uint32_t)m[i] | (((uint32_t)m[i+1] & 0x3F) << 8));\r\n        pk[j+1] = (((uint32_t)m[i+1] >> 6) | ((uint32_t)m[i+2] << 2) | (((uint32_t)m[i+3] & 0x0F) << 10));\r\n        pk[j+2] = (((uint32_t)m[i+3] >> 4) | ((uint32_t)m[i+4] << 4) | (((uint32_t)m[i+5] & 0x03) << 12));\r\n        pk[j+3] = (((uint32_t)m[i+5] >> 2) | ((uint32_t)m[i+6] << 6));\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    decode_asm(m, pk);\r\n    i = 1792;\r\n#endif\r\n\r\n    for (j = 0; j < 32; j++) {\r\n        seed[j] = m[i+j];\r\n    }\r\n}\r\n\r\n\r\nvoid encode_B(const uint32_t* pk, const uint32_t* rvec, unsigned char* m)\r\n{ // Bob's message encoding\r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION) \r\n    for (j = 0; j < 1024; j += 4) {        \r\n        m[i]   = (unsigned char)(pk[j] & 0xFF);\r\n        m[i+1] = (unsigned char)((pk[j] >> 8) | ((pk[j+1] & 0x03) << 6));\r\n        m[i+2] = (unsigned char)((pk[j+1] >> 2) & 0xFF);\r\n        m[i+3] = (unsigned char)((pk[j+1] >> 10) | ((pk[j+2] & 0x0F) << 4));\r\n        m[i+4] = (unsigned char)((pk[j+2] >> 4) & 0xFF);\r\n        m[i+5] = (unsigned char)((pk[j+2] >> 12) | ((pk[j+3] & 0x3F) << 2));\r\n        m[i+6] = (unsigned char)(pk[j+3] >> 6);\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    encode_asm(pk, m);\r\n#endif\r\n\r\n    i = 0;\r\n    for (j = 0; j < 1024/4; j++) {\r\n        m[1792+j] = (unsigned char)(rvec[i] | (rvec[i+1] << 2) | (rvec[i+2] << 4) | (rvec[i+3] << 6));\r\n        i += 4;\r\n    }\r\n}\r\n\r\n\r\nvoid decode_B(unsigned char* m, uint32_t* pk, uint32_t* rvec)\r\n{ // Bob's message decoding\r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION) \r\n    for (j = 0; j < 1024; j += 4) {        \r\n        pk[j]   = ((uint32_t)m[i] | (((uint32_t)m[i+1] & 0x3F) << 8));\r\n        pk[j+1] = (((uint32_t)m[i+1] >> 6) | ((uint32_t)m[i+2] << 2) | (((uint32_t)m[i+3] & 0x0F) << 10));\r\n        pk[j+2] = (((uint32_t)m[i+3] >> 4) | ((uint32_t)m[i+4] << 4) | (((uint32_t)m[i+5] & 0x03) << 12));\r\n        pk[j+3] = (((uint32_t)m[i+5] >> 2) | ((uint32_t)m[i+6] << 6));\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    decode_asm(m, pk);\r\n    i = 1792;\r\n#endif\r\n    \r\n    i = 0;\r\n    for (j = 0; j < 1024/4; j++) {\r\n        rvec[i]   = (uint32_t)(m[1792+j] & 0x03);\r\n        rvec[i+1] = (uint32_t)((m[1792+j] >> 2) & 0x03);\r\n        rvec[i+2] = (uint32_t)((m[1792+j] >> 4) & 0x03);\r\n        rvec[i+3] = (uint32_t)(m[1792+j] >> 6);\r\n        i += 4;\r\n    }\r\n}\r\n\r\n\r\nstatic __inline uint32_t Abs(int32_t value)\r\n{ // Compute absolute value\r\n    uint32_t mask;\r\n\r\n    mask = (uint32_t)(value >> 31);\r\n    return ((mask ^ value) - mask);\r\n}\r\n\r\n\r\nCRYPTO_STATUS HelpRec(const uint32_t* x, uint32_t* rvec, const unsigned char* seed, unsigned int nonce, StreamOutput StreamOutputFunction)\r\n{ // Reconciliation helper\r\n    unsigned int i, j, norm;\r\n    unsigned char bit, random_bits[32], nce[8] = {0};\r\n    uint32_t v0[4], v1[4];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n    \r\n    nce[1] = (unsigned char)nonce;                \r\n    Status = stream_output(seed, ERROR_SEED_BYTES, nce, NONCE_SEED_BYTES, 32, random_bits, StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)random_bits, NBYTES_TO_NWORDS(32));\r\n        return Status;\r\n    }    \r\n\r\n#if defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT)         \r\n    helprec_asm(x, rvec, random_bits);\r\n#else   \r\n\r\n    for (i = 0; i < 256; i++) {\r\n        bit = 1 & (random_bits[i >> 3] >> (i & 0x07));\r\n        rvec[i]     = (x[i]     << 1) - bit;  \r\n        rvec[i+256] = (x[i+256] << 1) - bit;\r\n        rvec[i+512] = (x[i+512] << 1) - bit;\r\n        rvec[i+768] = (x[i+768] << 1) - bit; \r\n\r\n        norm = 0;\r\n        v0[0] = 4; v0[1] = 4; v0[2] = 4; v0[3] = 4;\r\n        v1[0] = 3; v1[1] = 3; v1[2] = 3; v1[3] = 3; \r\n        for (j = 0; j < 4; j++) {\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_Q4 ) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_3Q4) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_5Q4) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_7Q4) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_Q2 ) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_Q  ) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_3Q2) >> 31;\r\n            norm += Abs(2*rvec[i+256*j] - PARAMETER_Q*v0[j]);\r\n        }\r\n\r\n        norm = (uint32_t)((int32_t)(norm - PARAMETER_Q) >> 31);    // If norm < q then norm = 0xff...ff, else norm = 0\r\n        v0[0] = (norm & (v0[0] ^ v1[0])) ^ v1[0];\r\n        v0[1] = (norm & (v0[1] ^ v1[1])) ^ v1[1];\r\n        v0[2] = (norm & (v0[2] ^ v1[2])) ^ v1[2];\r\n        v0[3] = (norm & (v0[3] ^ v1[3])) ^ v1[3];\r\n        rvec[i]     = (v0[0] - v0[3]) & 0x03;\r\n        rvec[i+256] = (v0[1] - v0[3]) & 0x03;\r\n        rvec[i+512] = (v0[2] - v0[3]) & 0x03;\r\n        rvec[i+768] = ((v0[3] << 1) + (1 & ~norm)) & 0x03;\r\n    }\r\n#endif\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nstatic __inline uint32_t LDDecode(int32_t* t)\r\n{ // Low-density decoding\r\n    unsigned int i, norm = 0;\r\n    uint32_t mask1, mask2, value;\r\n    int32_t cneg = -8*PARAMETER_Q;\r\n    \r\n\tfor (i = 0; i < 4; i++) { \r\n        mask1 = t[i] >> 31;                                    // If t[i] < 0 then mask2 = 0xff...ff, else mask2 = 0\r\n        mask2 = (4*PARAMETER_Q - (int32_t)Abs(t[i])) >> 31;    // If 4*PARAMETER_Q > Abs(t[i]) then mask2 = 0, else mask2 = 0xff...ff\r\n\r\n        value = ((mask1 & (8*PARAMETER_Q ^ cneg)) ^ cneg);\r\n\t\tnorm += Abs(t[i] + (mask2 & value));\r\n    }\r\n\r\n    return ((8*PARAMETER_Q - norm) >> 31) ^ 1;                 // If norm < PARAMETER_Q then return 1, else return 0\r\n};\r\n\r\n\r\nvoid Rec(const uint32_t *x, const uint32_t* rvec, unsigned char *key)               \r\n{ // Reconciliation\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    unsigned int i;\r\n    uint32_t t[4];\r\n\r\n    for (i = 0; i < 32; i++) {\r\n        key[i] = 0;\r\n    }\r\n    for (i = 0; i < 256; i++) {        \r\n        t[0] = 8*x[i]     - (2*rvec[i] + rvec[i+768]) * PARAMETER_Q;\r\n        t[1] = 8*x[i+256] - (2*rvec[i+256] + rvec[i+768]) * PARAMETER_Q;\r\n        t[2] = 8*x[i+512] - (2*rvec[i+512] + rvec[i+768]) * PARAMETER_Q;\r\n        t[3] = 8*x[i+768] - (rvec[i+768]) * PARAMETER_Q;\r\n      \r\n        key[i >> 3] |= (unsigned char)LDDecode((int32_t*)t) << (i & 0x07);\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    rec_asm(x, rvec, key);\r\n#endif\r\n}\r\n\r\n\r\nCRYPTO_STATUS get_error(int32_t* e, unsigned char* seed, unsigned int nonce, StreamOutput StreamOutputFunction)              \r\n{ // Error sampling\r\n    unsigned char stream[3*PARAMETER_N];    \r\n    uint32_t* pstream = (uint32_t*)&stream;   \r\n    uint32_t acc1, acc2, temp;  \r\n    uint8_t *pacc1 = (uint8_t*)&acc1, *pacc2 = (uint8_t*)&acc2;\r\n    unsigned char nce[8] = {0};\r\n    unsigned int i, j;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n    \r\n    nce[0] = (unsigned char)nonce;\r\n    Status = stream_output(seed, ERROR_SEED_BYTES, nce, NONCE_SEED_BYTES, 3*PARAMETER_N, stream, StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)stream, NBYTES_TO_NWORDS(3*PARAMETER_N));\r\n        return Status;\r\n    }    \r\n\r\n#if defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT)         \r\n    error_sampling_asm(stream, e);\r\n#else    \r\n    for (i = 0; i < PARAMETER_N/4; i++)\r\n    {\r\n        acc1 = 0;\r\n        acc2 = 0;\r\n        for (j = 0; j < 8; j++) {\r\n            acc1 += (pstream[i] >> j) & 0x01010101;\r\n            acc2 += (pstream[i+PARAMETER_N/4] >> j) & 0x01010101;\r\n        }\r\n        for (j = 0; j < 4; j++) {\r\n            temp = pstream[i+2*PARAMETER_N/4] >> j;\r\n            acc1 += temp & 0x01010101;\r\n            acc2 += (temp >> 4) & 0x01010101;\r\n        }\r\n        e[2*i]   = pacc1[0] - pacc1[1];                               \r\n        e[2*i+1] = pacc1[2] - pacc1[3];\r\n        e[2*i+PARAMETER_N/2]   = pacc2[0] - pacc2[1];               \r\n        e[2*i+PARAMETER_N/2+1] = pacc2[2] - pacc2[3];\r\n    }\r\n#endif\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS generate_a(uint32_t* a, const unsigned char* seed, ExtendableOutput ExtendableOutputFunction)             \r\n{ // Generation of parameter a\r\n\r\n    return extended_output(seed, SEED_BYTES, PARAMETER_N, a, ExtendableOutputFunction);\r\n}\r\n\r\n\r\nCRYPTO_STATUS KeyGeneration_A(int32_t* SecretKeyA, unsigned char* PublicKeyA, PLatticeCryptoStruct pLatticeCrypto) \r\n{ // Alice's key generation  \r\n  // It produces a private key SecretKeyA and computes the public key PublicKeyA.\r\n  // Outputs: the private key SecretKeyA that consists of a 32-bit signed 1024-element array (4096 bytes in total)\r\n  //          the public key PublicKeyA that occupies 1824 bytes\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t a[PARAMETER_N];\r\n    int32_t e[PARAMETER_N];\r\n    unsigned char seed[SEED_BYTES], error_seed[ERROR_SEED_BYTES];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    Status = random_bytes(SEED_BYTES, seed, pLatticeCrypto->RandomBytesFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    Status = random_bytes(ERROR_SEED_BYTES, error_seed, pLatticeCrypto->RandomBytesFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = generate_a(a, seed, pLatticeCrypto->ExtendableOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = get_error(SecretKeyA, error_seed, 0, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    Status = get_error(e, error_seed, 1, pLatticeCrypto->StreamOutputFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    NTT_CT_std2rev_12289(SecretKeyA, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N);\r\n    smul(e, 3, PARAMETER_N);\r\n\r\n    pmuladd((int32_t*)a, SecretKeyA, e, (int32_t*)a, PARAMETER_N); \r\n    correction((int32_t*)a, PARAMETER_Q, PARAMETER_N);\r\n    encode_A(a, seed, PublicKeyA);\r\n    \r\ncleanup:\r\n    clear_words((void*)e, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)error_seed, NBYTES_TO_NWORDS(ERROR_SEED_BYTES));\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_B(unsigned char* PublicKeyA, unsigned char* SharedSecretB, unsigned char* PublicKeyB, PLatticeCryptoStruct pLatticeCrypto) \r\n{ // Bob's key generation and shared secret computation  \r\n  // It produces a private key and computes the public key PublicKeyB. In combination with Alice's public key PublicKeyA, it computes \r\n  // the shared secret SharedSecretB.\r\n  // Input:   Alice's public key PublicKeyA that consists of 1824 bytes\r\n  // Outputs: the public key PublicKeyB that occupies 2048 bytes.\r\n  //          the 256-bit shared secret SharedSecretB.\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t pk_A[PARAMETER_N], a[PARAMETER_N], v[PARAMETER_N], r[PARAMETER_N];\r\n    int32_t sk_B[PARAMETER_N], e[PARAMETER_N];\r\n    unsigned char seed[SEED_BYTES], error_seed[ERROR_SEED_BYTES];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    decode_A(PublicKeyA, pk_A, seed);\r\n    Status = random_bytes(ERROR_SEED_BYTES, error_seed, pLatticeCrypto->RandomBytesFunction); \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = generate_a(a, seed, pLatticeCrypto->ExtendableOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = get_error(sk_B, error_seed, 0, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    Status = get_error(e, error_seed, 1, pLatticeCrypto->StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    NTT_CT_std2rev_12289(sk_B, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N);\r\n    smul(e, 3, PARAMETER_N);\r\n\r\n    pmuladd((int32_t*)a, sk_B, e, (int32_t*)a, PARAMETER_N); \r\n    correction((int32_t*)a, PARAMETER_Q, PARAMETER_N);\r\n     \r\n    Status = get_error(e, error_seed, 2, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    smul(e, 81, PARAMETER_N);\r\n    \r\n    pmuladd((int32_t*)pk_A, sk_B, e, (int32_t*)v, PARAMETER_N);    \r\n    INTT_GS_rev2std_12289((int32_t*)v, omegainv_rev_ntt1024_12289, omegainv10N_rev_ntt1024_12289, Ninv11_ntt1024_12289, PARAMETER_N);\r\n    two_reduce12289((int32_t*)v, PARAMETER_N);\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    correction((int32_t*)v, PARAMETER_Q, PARAMETER_N); \r\n#endif\r\n\r\n    Status = HelpRec(v, r, error_seed, 3, pLatticeCrypto->StreamOutputFunction); \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    Rec(v, r, SharedSecretB);\r\n    encode_B(a, r, PublicKeyB);\r\n    \r\ncleanup:\r\n    clear_words((void*)sk_B, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)e, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)error_seed, NBYTES_TO_NWORDS(ERROR_SEED_BYTES));\r\n    clear_words((void*)a, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)v, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)r, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_A(unsigned char* PublicKeyB, int32_t* SecretKeyA, unsigned char* SharedSecretA) \r\n{ // Alice's shared secret computation  \r\n  // It computes the shared secret SharedSecretA using Bob's public key PublicKeyB and Alice's private key SecretKeyA.\r\n  // Inputs: Bob's public key PublicKeyB that consists of 2048 bytes\r\n  //         the private key SecretKeyA that consists of a 32-bit signed 1024-element array (4096 bytes in total)\r\n  // Output: the 256-bit shared secret SharedSecretA.\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t u[PARAMETER_N], r[PARAMETER_N];\r\n    CRYPTO_STATUS Status = CRYPTO_SUCCESS;\r\n\r\n    decode_B(PublicKeyB, u, r);\r\n    \r\n    pmul(SecretKeyA, (int32_t*)u, (int32_t*)u, PARAMETER_N);       \r\n    INTT_GS_rev2std_12289((int32_t*)u, omegainv_rev_ntt1024_12289, omegainv10N_rev_ntt1024_12289, Ninv11_ntt1024_12289, PARAMETER_N);\r\n    two_reduce12289((int32_t*)u, PARAMETER_N);\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    correction((int32_t*)u, PARAMETER_Q, PARAMETER_N); \r\n#endif\r\n\r\n    Rec(u, r, SharedSecretA);\r\n    \r\n// Cleanup\r\n    clear_words((void*)u, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)r, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n\r\n    return Status;\r\n}\r\n","/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: wrappers for user-provided functions\r\n*\r\n*****************************************************************************************/\r\n\r\n\r\n#include \"LatticeCrypto_priv.h\"\r\n\r\n\r\nCRYPTO_STATUS random_bytes(unsigned int nbytes, unsigned char* random_array, RandomBytes RandomBytesFunction)\r\n{ // Output \"nbytes\" of random values.\r\n  // It makes requests of random values to RandomBytesFunction. If successful, the output is given in \"random_array\".\r\n  // The caller is responsible for providing the \"RandomBytesFunction\" function passing random values as octets.\r\n\r\n    if (random_array == NULL || RandomBytesFunction == NULL || nbytes == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (RandomBytesFunction)(nbytes, random_array);\r\n}\r\n\r\n\r\nCRYPTO_STATUS extended_output(const unsigned char* seed, unsigned int seed_nbytes, unsigned int array_ndigits, uint32_t* extended_array, ExtendableOutput ExtendableOutputFunction)\r\n{ // Output \"array_ndigits\" of values in [0, q-1] using an extendable-output function and a seed of size \"seed_nbytes\".\r\n  // It makes requests of values to ExtendableOutputFunction. If successful, the output is given in \"extended_array\".\r\n  // The caller is responsible for providing the \"ExtendableOutputFunction\" function passing values as 32-bit digits.\r\n\r\n    if (seed == NULL || extended_array == NULL || ExtendableOutputFunction == NULL || seed_nbytes == 0 || array_ndigits == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (ExtendableOutputFunction)(seed, seed_nbytes, array_ndigits, extended_array);\r\n}\r\n\r\n\r\nCRYPTO_STATUS stream_output(const unsigned char* seed, unsigned int seed_nbytes, unsigned char* nonce, unsigned int nonce_nbytes, unsigned int array_nbytes, unsigned char* stream_array, StreamOutput StreamOutputFunction)\r\n{ // Output \"array_nbytes\" of values using a stream cipher, a seed of size \"seed_nbytes\" and a nonce of size \"nonce_nbytes\".  \r\n  // It makes requests of values to StreamOutputFunction. If successful, the output is given in \"stream_array\".\r\n  // The caller is responsible for providing the \"StreamOutputFunction\" function passing values as octets.\r\n\r\n    if (seed == NULL || stream_array == NULL || StreamOutputFunction == NULL || seed_nbytes == 0 || nonce_nbytes == 0 || array_nbytes == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (StreamOutputFunction)(seed, seed_nbytes, nonce, nonce_nbytes, array_nbytes, stream_array);\r\n}","#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"LatticeCrypto_priv.h\"\n#include \"LatticeCrypto.h\"\n#include \"crypto_stream_chacha20.h\"\n#include \"randombytes.h\"\n#include \"utils.h\"\n\n\nPLatticeCryptoStruct lattice;\n\nlong public_key_bytes\t= PKB_BYTES;\nlong private_key_length\t= PARAMETER_N;\n\n\nCRYPTO_STATUS rlwejs_randombytes (unsigned int nbytes, unsigned char* random_array) {\n\trandombytes_buf(random_array, nbytes);\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS rlwejs_streamoutput (\n\tconst unsigned char* seed,\n\tunsigned int seed_nbytes,\n\tunsigned char* nonce,\n\tunsigned int nonce_nbytes,\n\tunsigned int array_nbytes,\n\tunsigned char* stream_array\n) {\n\tunsigned char* k\t= (unsigned char*) seed;\n\tif (seed_nbytes < crypto_stream_chacha20_KEYBYTES) {\n\t\tk\t= calloc(crypto_stream_chacha20_KEYBYTES, 1);\n\t\tif (seed_nbytes > 0) {\n\t\t\tmemcpy(k, seed, seed_nbytes);\n\t\t}\n\t}\n\n\tunsigned char* n\t= nonce;\n\tif (nonce_nbytes < crypto_stream_chacha20_NONCEBYTES) {\n\t\tn\t= calloc(crypto_stream_chacha20_NONCEBYTES, 1);\n\t\tif (nonce_nbytes > 0) {\n\t\t\tmemcpy(n, nonce, nonce_nbytes);\n\t\t}\n\t}\n\n\tint status\t= crypto_stream_chacha20(stream_array, array_nbytes, n, k);\n\n\tif (k != seed) {\n\t\tsodium_memzero(k, crypto_stream_chacha20_KEYBYTES);\n\t\tfree(k);\n\t}\n\n\tif (n != nonce) {\n\t\tsodium_memzero(n, crypto_stream_chacha20_NONCEBYTES);\n\t\tfree(n);\n\t}\n\n\tif (status != 0) {\n\t\treturn CRYPTO_ERROR_UNKNOWN;\n\t}\n\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS rlwejs_extendableoutput (\n\tconst unsigned char* seed,\n\tunsigned int seed_nbytes,\n\tunsigned int array_ndigits,\n\tuint32_t extended_array[]\n) {\n\tCRYPTO_STATUS status\t= rlwejs_streamoutput(\n\t\tseed,\n\t\tseed_nbytes,\n\t\tNULL,\n\t\t0,\n\t\tarray_ndigits * 4,\n\t\t(unsigned char*) extended_array\n\t);\n\n\tif (status != CRYPTO_SUCCESS) {\n\t\treturn status;\n\t}\n\n\tfor (int i = 0 ; i < array_ndigits ; ++i) {\n\t\textended_array[i]\t= extended_array[i] % PARAMETER_Q;\n\t}\n\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS rlwejs_init () {\n\trandombytes_stir();\n\n\tlattice\t= LatticeCrypto_allocate();\n\n\treturn LatticeCrypto_initialize(\n\t\tlattice,\n\t\trlwejs_randombytes,\n\t\trlwejs_extendableoutput,\n\t\trlwejs_streamoutput\n\t);\n}\n\nlong rlwejs_public_key_bytes () {\n\treturn public_key_bytes + 1;\n}\n\nlong rlwejs_private_key_bytes () {\n\treturn (private_key_length + 1) * 4;\n}\n\nlong rlwejs_secret_bytes () {\n\treturn SHAREDKEY_BYTES;\n}\n\nCRYPTO_STATUS rlwejs_keypair_alice (\n\tuint8_t public_key[],\n\tint32_t private_key[]\n) {\n\tCRYPTO_STATUS status\t= KeyGeneration_A(private_key, public_key, lattice);\n\n\tpublic_key[public_key_bytes]\t= 1;\n\tprivate_key[private_key_length]\t= 1;\n\n\treturn status;\n}\n\nCRYPTO_STATUS rlwejs_secret_alice (\n\tuint8_t public_key[],\n\tint32_t private_key[],\n\tuint8_t* secret\n) {\n\tif (public_key[public_key_bytes] || !private_key[private_key_length]) {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\treturn SecretAgreement_A(public_key, private_key, secret);\n}\n\nCRYPTO_STATUS rlwejs_secret_bob (\n\tuint8_t public_key_alice[],\n\tuint8_t public_key_bob[],\n\tuint8_t* secret\n) {\n\tif (!public_key_alice[public_key_bytes]) {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\tCRYPTO_STATUS status\t= SecretAgreement_B(public_key_alice, secret, public_key_bob, lattice);\n\n\tpublic_key_bob[public_key_bytes]\t= 0;\n\n\treturn status;\n}\n"]}