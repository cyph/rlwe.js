{"version":3,"file":"dist/rlwe.debug.js","sources":["libsodium/src/libsodium/randombytes/randombytes.c","LatticeCrypto_v1.0/generic/ntt.c","LatticeCrypto_v1.0/kex.c","LatticeCrypto_v1.0/random.c","rlwe.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;AAAA;;;;;AAeA;AA4BA;;;;;;;;;;AAsCA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;AC1IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAeA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAYA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAIA;AAAA;;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AATA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AAfA;AAAA;AAAA;;AAiBA;AAAA;AAAA;AApBA;AAAA;AAAA;;AAsBA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;;;;;;;;;;;AAQA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;AAOA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;AAQA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;;;;;;;;;;ACtJA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;AAOA;AAEA;AAAA;AAEA;AAAA;;AACA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AA8BA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;AAAA;AAAA;;AAgBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAaA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;AAAA;AAAA;;AAeA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;AAKA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAaA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AACA;AAAA;AAyCA;AAAA;;AAlCA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA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","sourcesContent":["\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"randombytes_sysrandom.h\"\n\n#ifdef __native_client__\n# include \"randombytes_nativeclient.h\"\n#endif\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifdef __EMSCRIPTEN__\n# define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n#else\n# ifdef __native_client__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n# else\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\n/*\n * randombytes_uniform() derives from OpenBSD's arc4random_uniform()\n * Copyright (c) 2008, Damien Miller <djm@openbsd.org>\n */\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (uint32_t) (-upper_bound % upper_bound);\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: NTT functions and other polynomial operations\r\n*\r\n*****************************************************************************************/\r\n\r\n#include \"../LatticeCrypto_priv.h\"\r\n\r\nconst uint32_t mask12 = ((uint64_t)1 << 12) - 1;\r\n\r\n    \r\nint32_t reduce12289(int64_t a)\r\n{ // Reduction modulo q\r\n    int32_t c0, c1;\r\n   \r\n    c0 = (int32_t)(a & mask12);\r\n    c1 = (int32_t)(a >> 12);\r\n \r\n    return (3*c0 - c1);\r\n}\r\n\r\n    \r\nint32_t reduce12289_2x(int64_t a)\r\n{ // Two merged reductions modulo q\r\n    int32_t c0, c1, c2;\r\n   \r\n    c0 = (int32_t)(a & mask12);\r\n    c1 = (int32_t)((a >> 12) & mask12);\r\n    c2 = (int32_t)(a >> 24);\r\n \r\n    return (9*c0 - 3*c1 + c2);\r\n}\r\n\r\n\r\nvoid NTT_CT_std2rev_12289(int32_t* a, const int32_t* psi_rev, unsigned int N)\r\n{ // Forward NTT\r\n    unsigned int m, i, j, j1, j2, k = N;\r\n    int32_t S, U, V;\r\n\r\n    for (m = 1; m < 128; m = 2*m) {\r\n        k = k >> 1;\r\n        for (i = 0; i < m; i++) {\r\n            j1 = 2*i*k;\r\n            j2 = j1+k-1;\r\n            S = psi_rev[m+i];\r\n            for (j = j1; j <= j2; j++) { \r\n                U = a[j]; \r\n                V = reduce12289((int64_t)a[j+k]*S);\r\n                a[j] = U+V;\r\n                a[j+k] = U-V;\r\n            }\r\n        }\r\n    }\r\n\r\n    k = 4;\r\n    for (i = 0; i < 128; i++) {\r\n        j1 = 8*i;\r\n        j2 = j1+3;\r\n        S = psi_rev[i+128];\r\n        for (j = j1; j <= j2; j++) {\r\n            U = reduce12289((int64_t)a[j]);\r\n            V = reduce12289_2x((int64_t)a[j+4]*S);\r\n            a[j] = U+V;\r\n            a[j+4] = U-V;\r\n        }\r\n    }\r\n\r\n    for (m = 256; m < N; m = 2*m) {\r\n        k = k >> 1;\r\n        for (i = 0; i < m; i++) {\r\n            j1 = 2*i*k;\r\n            j2 = j1+k-1;\r\n            S = psi_rev[m+i];\r\n            for (j = j1; j <= j2; j++) { \r\n                U = a[j]; \r\n                V = reduce12289((int64_t)a[j+k]*S); \r\n                a[j] = U+V;\r\n                a[j+k] = U-V;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\n\r\nvoid INTT_GS_rev2std_12289(int32_t* a, const int32_t* omegainv_rev, const int32_t omegainv1N_rev, const int32_t Ninv, unsigned int N)\r\n{ // Inverse NTT\r\n    unsigned int m, h, i, j, j1, j2, k = 1;\r\n    int32_t S, U, V;\r\n    int64_t temp;\r\n\r\n    for (m = N; m > 2; m >>= 1) {\r\n        j1 = 0;\r\n        h = m >> 1;\r\n        for (i = 0; i < h; i++) {\r\n            j2 = j1+k-1;\r\n            S = omegainv_rev[h+i];\r\n            for (j = j1; j <= j2; j++) {\r\n                U = a[j];\r\n                V = a[j+k];\r\n                a[j] = U+V;\r\n                temp = (int64_t)(U-V)*S;\r\n                if (m == 32) {\r\n                    a[j] = reduce12289((int64_t)a[j]);\r\n                    a[j+k] = reduce12289_2x(temp);\r\n                } else {\r\n                    a[j+k] = reduce12289(temp);\r\n                }\r\n             }\r\n             j1 = j1+2*k;\r\n        }\r\n        k = 2*k;\r\n    }\r\n    for (j = 0; j < k; j++) {\r\n        U = a[j];\r\n        V = a[j+k];\r\n        a[j] = reduce12289((int64_t)(U+V)*Ninv);\r\n        a[j+k] = reduce12289((int64_t)(U-V)*omegainv1N_rev);\r\n    }\r\n    return;\r\n}\r\n\r\n\r\nvoid two_reduce12289(int32_t* a, unsigned int N)\r\n{ // Two consecutive reductions modulo q\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        a[i] = reduce12289((int64_t)a[i]);\r\n        a[i] = reduce12289((int64_t)a[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid pmul(int32_t* a, int32_t* b, int32_t* c, unsigned int N)\r\n{ // Component-wise multiplication\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        c[i] = reduce12289((int64_t)a[i]*b[i]);\r\n        c[i] = reduce12289((int64_t)c[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid pmuladd(int32_t* a, int32_t* b, int32_t* c, int32_t* d, unsigned int N)\r\n{ // Component-wise multiplication and addition\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        d[i] = reduce12289((int64_t)a[i]*b[i] + c[i]);\r\n        d[i] = reduce12289((int64_t)d[i]);\r\n    }\r\n}\r\n\r\n\r\nvoid smul(int32_t* a, int32_t scalar, unsigned int N)\r\n{ // Component-wise multiplication with scalar\r\n    unsigned int i; \r\n\r\n    for (i = 0; i < N; i++) {\r\n        a[i] = a[i]*scalar;\r\n    }\r\n}\r\n\r\n\r\nvoid correction(int32_t* a, int32_t p, unsigned int N)\r\n{ // Correction modulo q \r\n    unsigned int i; \r\n    int32_t mask;\r\n\r\n    for (i = 0; i < N; i++) {\r\n        mask = a[i] >> (4*sizeof(int32_t) - 1);\r\n        a[i] += (p & mask) - p;\r\n        mask = a[i] >> (4*sizeof(int32_t) - 1);\r\n        a[i] += (p & mask);\r\n    }\r\n}\r\n","#include <stdlib.h>\n/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: Ring-LWE key exchange\r\n*           The implementation is based on the instantiation of Peikert's key exchange [1]\r\n*           due to Alkim, Ducas, Poppelmann and Schwabe [2].\r\n*\r\n* [1] C. Peikert, \"Lattice cryptography for the internet\", in Post-Quantum Cryptography - \r\n*     6th International Workshop (PQCrypto 2014), LNCS 8772, pp. 197-219. Springer, 2014.\r\n* [2] E. Alkim, L. Ducas, T. Pï¿½ppelmann and P. Schwabe, \"Post-quantum key exchange - a new \r\n*     hope\", IACR Cryptology ePrint Archive, Report 2015/1092, 2015.\r\n*\r\n******************************************************************************************/ \r\n\r\n#include \"LatticeCrypto_priv.h\"\r\n#include <malloc.h>\r\n\r\nextern const int32_t psi_rev_ntt1024_12289[1024];           \r\nextern const int32_t omegainv_rev_ntt1024_12289[1024];\r\nextern const int32_t omegainv10N_rev_ntt1024_12289;\r\nextern const int32_t Ninv11_ntt1024_12289;\r\n\r\n\r\n__inline void clear_words(void* mem, digit_t nwords)\r\n{ // Clear digits from memory. \"nwords\" indicates the number of digits to be zeroed.\r\n  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.\r\n    unsigned int i;\r\n    volatile digit_t *v = mem; \r\n\r\n    for (i = 0; i < nwords; i++) {\r\n        v[i] = 0;\r\n    }\r\n}\r\n\r\n\r\nCRYPTO_STATUS LatticeCrypto_initialize(PLatticeCryptoStruct pLatticeCrypto, RandomBytes RandomBytesFunction, ExtendableOutput ExtendableOutputFunction, StreamOutput StreamOutputFunction)\r\n{ // Initialize structure pLatticeCrypto with user-provided functions: RandomBytesFunction, ExtendableOutputFunction and StreamOutputFunction.\r\n\r\n    pLatticeCrypto->RandomBytesFunction = RandomBytesFunction;\r\n    pLatticeCrypto->ExtendableOutputFunction = ExtendableOutputFunction;\r\n    pLatticeCrypto->StreamOutputFunction = StreamOutputFunction;\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nPLatticeCryptoStruct LatticeCrypto_allocate()\r\n{ // Dynamic allocation of memory for LatticeCrypto structure. It should be called before initialization with LatticeCrypto_initialize(). \r\n  // Returns NULL on error.\r\n    PLatticeCryptoStruct LatticeCrypto = NULL;\r\n\r\n    LatticeCrypto = (PLatticeCryptoStruct)calloc(1, sizeof(LatticeCryptoStruct));\r\n\r\n    if (LatticeCrypto == NULL) {\r\n        return NULL;\r\n    }\r\n    return LatticeCrypto;\r\n}\r\n\r\n\r\nconst char* LatticeCrypto_get_error_message(CRYPTO_STATUS Status)\r\n{ // Output error/success message for a given CRYPTO_STATUS\r\n    struct error_mapping {\r\n        unsigned int index;\r\n        char*        string;\r\n    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {\r\n        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},\r\n        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},\r\n        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},\r\n        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},\r\n        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},\r\n        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},\r\n        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},\r\n        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},\r\n        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}\r\n    };\r\n\r\n    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {\r\n        return \"Unrecognized CRYPTO_STATUS\";\r\n    } else {\r\n        return mapping[Status].string;\r\n    }\r\n};\r\n\r\n\r\nvoid encode_A(const uint32_t* pk, const unsigned char* seed, unsigned char* m)\r\n{ // Alice's message encoding\r\n    unsigned int i = 0, j;\r\n        \r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    for (j = 0; j < 1024; j += 4) {        \r\n        m[i]   = (unsigned char)(pk[j] & 0xFF);\r\n        m[i+1] = (unsigned char)((pk[j] >> 8) | ((pk[j+1] & 0x03) << 6));\r\n        m[i+2] = (unsigned char)((pk[j+1] >> 2) & 0xFF);\r\n        m[i+3] = (unsigned char)((pk[j+1] >> 10) | ((pk[j+2] & 0x0F) << 4));\r\n        m[i+4] = (unsigned char)((pk[j+2] >> 4) & 0xFF);\r\n        m[i+5] = (unsigned char)((pk[j+2] >> 12) | ((pk[j+3] & 0x3F) << 2));\r\n        m[i+6] = (unsigned char)(pk[j+3] >> 6);\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    encode_asm(pk, m);\r\n    i = 1792;\r\n#endif\r\n\r\n    for (j = 0; j < 32; j++) {\r\n        m[i+j] = seed[j];\r\n    }\r\n}\r\n\r\n\r\nvoid decode_A(const unsigned char* m, uint32_t *pk, unsigned char* seed)\r\n{ // Alice's message decoding \r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    for (j = 0; j < 1024; j += 4) {        \r\n        pk[j]   = ((uint32_t)m[i] | (((uint32_t)m[i+1] & 0x3F) << 8));\r\n        pk[j+1] = (((uint32_t)m[i+1] >> 6) | ((uint32_t)m[i+2] << 2) | (((uint32_t)m[i+3] & 0x0F) << 10));\r\n        pk[j+2] = (((uint32_t)m[i+3] >> 4) | ((uint32_t)m[i+4] << 4) | (((uint32_t)m[i+5] & 0x03) << 12));\r\n        pk[j+3] = (((uint32_t)m[i+5] >> 2) | ((uint32_t)m[i+6] << 6));\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    decode_asm(m, pk);\r\n    i = 1792;\r\n#endif\r\n\r\n    for (j = 0; j < 32; j++) {\r\n        seed[j] = m[i+j];\r\n    }\r\n}\r\n\r\n\r\nvoid encode_B(const uint32_t* pk, const uint32_t* rvec, unsigned char* m)\r\n{ // Bob's message encoding\r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION) \r\n    for (j = 0; j < 1024; j += 4) {        \r\n        m[i]   = (unsigned char)(pk[j] & 0xFF);\r\n        m[i+1] = (unsigned char)((pk[j] >> 8) | ((pk[j+1] & 0x03) << 6));\r\n        m[i+2] = (unsigned char)((pk[j+1] >> 2) & 0xFF);\r\n        m[i+3] = (unsigned char)((pk[j+1] >> 10) | ((pk[j+2] & 0x0F) << 4));\r\n        m[i+4] = (unsigned char)((pk[j+2] >> 4) & 0xFF);\r\n        m[i+5] = (unsigned char)((pk[j+2] >> 12) | ((pk[j+3] & 0x3F) << 2));\r\n        m[i+6] = (unsigned char)(pk[j+3] >> 6);\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    encode_asm(pk, m);\r\n#endif\r\n\r\n    i = 0;\r\n    for (j = 0; j < 1024/4; j++) {\r\n        m[1792+j] = (unsigned char)(rvec[i] | (rvec[i+1] << 2) | (rvec[i+2] << 4) | (rvec[i+3] << 6));\r\n        i += 4;\r\n    }\r\n}\r\n\r\n\r\nvoid decode_B(unsigned char* m, uint32_t* pk, uint32_t* rvec)\r\n{ // Bob's message decoding\r\n    unsigned int i = 0, j;\r\n    \r\n#if defined(GENERIC_IMPLEMENTATION) \r\n    for (j = 0; j < 1024; j += 4) {        \r\n        pk[j]   = ((uint32_t)m[i] | (((uint32_t)m[i+1] & 0x3F) << 8));\r\n        pk[j+1] = (((uint32_t)m[i+1] >> 6) | ((uint32_t)m[i+2] << 2) | (((uint32_t)m[i+3] & 0x0F) << 10));\r\n        pk[j+2] = (((uint32_t)m[i+3] >> 4) | ((uint32_t)m[i+4] << 4) | (((uint32_t)m[i+5] & 0x03) << 12));\r\n        pk[j+3] = (((uint32_t)m[i+5] >> 2) | ((uint32_t)m[i+6] << 6));\r\n        i += 7;\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    decode_asm(m, pk);\r\n    i = 1792;\r\n#endif\r\n    \r\n    i = 0;\r\n    for (j = 0; j < 1024/4; j++) {\r\n        rvec[i]   = (uint32_t)(m[1792+j] & 0x03);\r\n        rvec[i+1] = (uint32_t)((m[1792+j] >> 2) & 0x03);\r\n        rvec[i+2] = (uint32_t)((m[1792+j] >> 4) & 0x03);\r\n        rvec[i+3] = (uint32_t)(m[1792+j] >> 6);\r\n        i += 4;\r\n    }\r\n}\r\n\r\n\r\nstatic __inline uint32_t Abs(int32_t value)\r\n{ // Compute absolute value\r\n    uint32_t mask;\r\n\r\n    mask = (uint32_t)(value >> 31);\r\n    return ((mask ^ value) - mask);\r\n}\r\n\r\n\r\nCRYPTO_STATUS HelpRec(const uint32_t* x, uint32_t* rvec, const unsigned char* seed, unsigned int nonce, StreamOutput StreamOutputFunction)\r\n{ // Reconciliation helper\r\n    unsigned int i, j, norm;\r\n    unsigned char bit, random_bits[32], nce[8] = {0};\r\n    uint32_t v0[4], v1[4];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n    \r\n    nce[1] = (unsigned char)nonce;                \r\n    Status = stream_output(seed, ERROR_SEED_BYTES, nce, NONCE_SEED_BYTES, 32, random_bits, StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)random_bits, NBYTES_TO_NWORDS(32));\r\n        return Status;\r\n    }    \r\n\r\n#if defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT)         \r\n    helprec_asm(x, rvec, random_bits);\r\n#else   \r\n\r\n    for (i = 0; i < 256; i++) {\r\n        bit = 1 & (random_bits[i >> 3] >> (i & 0x07));\r\n        rvec[i]     = (x[i]     << 1) - bit;  \r\n        rvec[i+256] = (x[i+256] << 1) - bit;\r\n        rvec[i+512] = (x[i+512] << 1) - bit;\r\n        rvec[i+768] = (x[i+768] << 1) - bit; \r\n\r\n        norm = 0;\r\n        v0[0] = 4; v0[1] = 4; v0[2] = 4; v0[3] = 4;\r\n        v1[0] = 3; v1[1] = 3; v1[2] = 3; v1[3] = 3; \r\n        for (j = 0; j < 4; j++) {\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_Q4 ) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_3Q4) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_5Q4) >> 31;\r\n            v0[j] -= (rvec[i+256*j] - PARAMETER_7Q4) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_Q2 ) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_Q  ) >> 31;\r\n            v1[j] -= (rvec[i+256*j] - PARAMETER_3Q2) >> 31;\r\n            norm += Abs(2*rvec[i+256*j] - PARAMETER_Q*v0[j]);\r\n        }\r\n\r\n        norm = (uint32_t)((int32_t)(norm - PARAMETER_Q) >> 31);    // If norm < q then norm = 0xff...ff, else norm = 0\r\n        v0[0] = (norm & (v0[0] ^ v1[0])) ^ v1[0];\r\n        v0[1] = (norm & (v0[1] ^ v1[1])) ^ v1[1];\r\n        v0[2] = (norm & (v0[2] ^ v1[2])) ^ v1[2];\r\n        v0[3] = (norm & (v0[3] ^ v1[3])) ^ v1[3];\r\n        rvec[i]     = (v0[0] - v0[3]) & 0x03;\r\n        rvec[i+256] = (v0[1] - v0[3]) & 0x03;\r\n        rvec[i+512] = (v0[2] - v0[3]) & 0x03;\r\n        rvec[i+768] = ((v0[3] << 1) + (1 & ~norm)) & 0x03;\r\n    }\r\n#endif\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nstatic __inline uint32_t LDDecode(int32_t* t)\r\n{ // Low-density decoding\r\n    unsigned int i, norm = 0;\r\n    uint32_t mask1, mask2, value;\r\n    int32_t cneg = -8*PARAMETER_Q;\r\n    \r\n\tfor (i = 0; i < 4; i++) { \r\n        mask1 = t[i] >> 31;                                    // If t[i] < 0 then mask2 = 0xff...ff, else mask2 = 0\r\n        mask2 = (4*PARAMETER_Q - (int32_t)Abs(t[i])) >> 31;    // If 4*PARAMETER_Q > Abs(t[i]) then mask2 = 0, else mask2 = 0xff...ff\r\n\r\n        value = ((mask1 & (8*PARAMETER_Q ^ cneg)) ^ cneg);\r\n\t\tnorm += Abs(t[i] + (mask2 & value));\r\n    }\r\n\r\n    return ((8*PARAMETER_Q - norm) >> 31) ^ 1;                 // If norm < PARAMETER_Q then return 1, else return 0\r\n};\r\n\r\n\r\nvoid Rec(const uint32_t *x, const uint32_t* rvec, unsigned char *key)               \r\n{ // Reconciliation\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    unsigned int i;\r\n    uint32_t t[4];\r\n\r\n    for (i = 0; i < 32; i++) {\r\n        key[i] = 0;\r\n    }\r\n    for (i = 0; i < 256; i++) {        \r\n        t[0] = 8*x[i]     - (2*rvec[i] + rvec[i+768]) * PARAMETER_Q;\r\n        t[1] = 8*x[i+256] - (2*rvec[i+256] + rvec[i+768]) * PARAMETER_Q;\r\n        t[2] = 8*x[i+512] - (2*rvec[i+512] + rvec[i+768]) * PARAMETER_Q;\r\n        t[3] = 8*x[i+768] - (rvec[i+768]) * PARAMETER_Q;\r\n      \r\n        key[i >> 3] |= (unsigned char)LDDecode((int32_t*)t) << (i & 0x07);\r\n    }\r\n    \r\n#elif defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT) \r\n    rec_asm(x, rvec, key);\r\n#endif\r\n}\r\n\r\n\r\nCRYPTO_STATUS get_error(int32_t* e, unsigned char* seed, unsigned int nonce, StreamOutput StreamOutputFunction)              \r\n{ // Error sampling\r\n    unsigned char stream[3*PARAMETER_N];    \r\n    uint32_t* pstream = (uint32_t*)&stream;   \r\n    uint32_t acc1, acc2, temp;  \r\n    uint8_t *pacc1 = (uint8_t*)&acc1, *pacc2 = (uint8_t*)&acc2;\r\n    unsigned char nce[8] = {0};\r\n    unsigned int i, j;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n    \r\n    nce[0] = (unsigned char)nonce;\r\n    Status = stream_output(seed, ERROR_SEED_BYTES, nce, NONCE_SEED_BYTES, 3*PARAMETER_N, stream, StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)stream, NBYTES_TO_NWORDS(3*PARAMETER_N));\r\n        return Status;\r\n    }    \r\n\r\n#if defined(ASM_SUPPORT) && (SIMD_SUPPORT == AVX2_SUPPORT)         \r\n    error_sampling_asm(stream, e);\r\n#else    \r\n    for (i = 0; i < PARAMETER_N/4; i++)\r\n    {\r\n        acc1 = 0;\r\n        acc2 = 0;\r\n        for (j = 0; j < 8; j++) {\r\n            acc1 += (pstream[i] >> j) & 0x01010101;\r\n            acc2 += (pstream[i+PARAMETER_N/4] >> j) & 0x01010101;\r\n        }\r\n        for (j = 0; j < 4; j++) {\r\n            temp = pstream[i+2*PARAMETER_N/4] >> j;\r\n            acc1 += temp & 0x01010101;\r\n            acc2 += (temp >> 4) & 0x01010101;\r\n        }\r\n        e[2*i]   = pacc1[0] - pacc1[1];                               \r\n        e[2*i+1] = pacc1[2] - pacc1[3];\r\n        e[2*i+PARAMETER_N/2]   = pacc2[0] - pacc2[1];               \r\n        e[2*i+PARAMETER_N/2+1] = pacc2[2] - pacc2[3];\r\n    }\r\n#endif\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS generate_a(uint32_t* a, const unsigned char* seed, ExtendableOutput ExtendableOutputFunction)             \r\n{ // Generation of parameter a\r\n\r\n    return extended_output(seed, SEED_BYTES, PARAMETER_N, a, ExtendableOutputFunction);\r\n}\r\n\r\n\r\nCRYPTO_STATUS KeyGeneration_A(int32_t* SecretKeyA, unsigned char* PublicKeyA, PLatticeCryptoStruct pLatticeCrypto) \r\n{ // Alice's key generation  \r\n  // It produces a private key SecretKeyA and computes the public key PublicKeyA.\r\n  // Outputs: the private key SecretKeyA that consists of a 32-bit signed 1024-element array (4096 bytes in total)\r\n  //          the public key PublicKeyA that occupies 1824 bytes\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t a[PARAMETER_N];\r\n    int32_t e[PARAMETER_N];\r\n    unsigned char seed[SEED_BYTES], error_seed[ERROR_SEED_BYTES];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    Status = random_bytes(SEED_BYTES, seed, pLatticeCrypto->RandomBytesFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    Status = random_bytes(ERROR_SEED_BYTES, error_seed, pLatticeCrypto->RandomBytesFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = generate_a(a, seed, pLatticeCrypto->ExtendableOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = get_error(SecretKeyA, error_seed, 0, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    Status = get_error(e, error_seed, 1, pLatticeCrypto->StreamOutputFunction);   \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    NTT_CT_std2rev_12289(SecretKeyA, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N);\r\n    smul(e, 3, PARAMETER_N);\r\n\r\n    pmuladd((int32_t*)a, SecretKeyA, e, (int32_t*)a, PARAMETER_N); \r\n    correction((int32_t*)a, PARAMETER_Q, PARAMETER_N);\r\n    encode_A(a, seed, PublicKeyA);\r\n    \r\ncleanup:\r\n    clear_words((void*)e, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)error_seed, NBYTES_TO_NWORDS(ERROR_SEED_BYTES));\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_B(unsigned char* PublicKeyA, unsigned char* SharedSecretB, unsigned char* PublicKeyB, PLatticeCryptoStruct pLatticeCrypto) \r\n{ // Bob's key generation and shared secret computation  \r\n  // It produces a private key and computes the public key PublicKeyB. In combination with Alice's public key PublicKeyA, it computes \r\n  // the shared secret SharedSecretB.\r\n  // Input:   Alice's public key PublicKeyA that consists of 1824 bytes\r\n  // Outputs: the public key PublicKeyB that occupies 2048 bytes.\r\n  //          the 256-bit shared secret SharedSecretB.\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t pk_A[PARAMETER_N], a[PARAMETER_N], v[PARAMETER_N], r[PARAMETER_N];\r\n    int32_t sk_B[PARAMETER_N], e[PARAMETER_N];\r\n    unsigned char seed[SEED_BYTES], error_seed[ERROR_SEED_BYTES];\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    decode_A(PublicKeyA, pk_A, seed);\r\n    Status = random_bytes(ERROR_SEED_BYTES, error_seed, pLatticeCrypto->RandomBytesFunction); \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = generate_a(a, seed, pLatticeCrypto->ExtendableOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n\r\n    Status = get_error(sk_B, error_seed, 0, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }\r\n    Status = get_error(e, error_seed, 1, pLatticeCrypto->StreamOutputFunction);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    NTT_CT_std2rev_12289(sk_B, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N);\r\n    smul(e, 3, PARAMETER_N);\r\n\r\n    pmuladd((int32_t*)a, sk_B, e, (int32_t*)a, PARAMETER_N); \r\n    correction((int32_t*)a, PARAMETER_Q, PARAMETER_N);\r\n     \r\n    Status = get_error(e, error_seed, 2, pLatticeCrypto->StreamOutputFunction);  \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    NTT_CT_std2rev_12289(e, psi_rev_ntt1024_12289, PARAMETER_N); \r\n    smul(e, 81, PARAMETER_N);\r\n    \r\n    pmuladd((int32_t*)pk_A, sk_B, e, (int32_t*)v, PARAMETER_N);    \r\n    INTT_GS_rev2std_12289((int32_t*)v, omegainv_rev_ntt1024_12289, omegainv10N_rev_ntt1024_12289, Ninv11_ntt1024_12289, PARAMETER_N);\r\n    two_reduce12289((int32_t*)v, PARAMETER_N);\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    correction((int32_t*)v, PARAMETER_Q, PARAMETER_N); \r\n#endif\r\n\r\n    Status = HelpRec(v, r, error_seed, 3, pLatticeCrypto->StreamOutputFunction); \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        goto cleanup;\r\n    }   \r\n    Rec(v, r, SharedSecretB);\r\n    encode_B(a, r, PublicKeyB);\r\n    \r\ncleanup:\r\n    clear_words((void*)sk_B, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)e, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)error_seed, NBYTES_TO_NWORDS(ERROR_SEED_BYTES));\r\n    clear_words((void*)a, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)v, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)r, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_A(unsigned char* PublicKeyB, int32_t* SecretKeyA, unsigned char* SharedSecretA) \r\n{ // Alice's shared secret computation  \r\n  // It computes the shared secret SharedSecretA using Bob's public key PublicKeyB and Alice's private key SecretKeyA.\r\n  // Inputs: Bob's public key PublicKeyB that consists of 2048 bytes\r\n  //         the private key SecretKeyA that consists of a 32-bit signed 1024-element array (4096 bytes in total)\r\n  // Output: the 256-bit shared secret SharedSecretA.\r\n  // pLatticeCrypto must be set up in advance using LatticeCrypto_initialize().\r\n    uint32_t u[PARAMETER_N], r[PARAMETER_N];\r\n    CRYPTO_STATUS Status = CRYPTO_SUCCESS;\r\n\r\n    decode_B(PublicKeyB, u, r);\r\n    \r\n    pmul(SecretKeyA, (int32_t*)u, (int32_t*)u, PARAMETER_N);       \r\n    INTT_GS_rev2std_12289((int32_t*)u, omegainv_rev_ntt1024_12289, omegainv10N_rev_ntt1024_12289, Ninv11_ntt1024_12289, PARAMETER_N);\r\n    two_reduce12289((int32_t*)u, PARAMETER_N);\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n    correction((int32_t*)u, PARAMETER_Q, PARAMETER_N); \r\n#endif\r\n\r\n    Rec(u, r, SharedSecretA);\r\n    \r\n// Cleanup\r\n    clear_words((void*)u, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n    clear_words((void*)r, NBYTES_TO_NWORDS(4*PARAMETER_N));\r\n\r\n    return Status;\r\n}\r\n","/****************************************************************************************\r\n* LatticeCrypto: an efficient post-quantum Ring-Learning With Errors cryptography library\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: wrappers for user-provided functions\r\n*\r\n*****************************************************************************************/\r\n\r\n\r\n#include \"LatticeCrypto_priv.h\"\r\n\r\n\r\nCRYPTO_STATUS random_bytes(unsigned int nbytes, unsigned char* random_array, RandomBytes RandomBytesFunction)\r\n{ // Output \"nbytes\" of random values.\r\n  // It makes requests of random values to RandomBytesFunction. If successful, the output is given in \"random_array\".\r\n  // The caller is responsible for providing the \"RandomBytesFunction\" function passing random values as octets.\r\n\r\n    if (random_array == NULL || RandomBytesFunction == NULL || nbytes == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (RandomBytesFunction)(nbytes, random_array);\r\n}\r\n\r\n\r\nCRYPTO_STATUS extended_output(const unsigned char* seed, unsigned int seed_nbytes, unsigned int array_ndigits, uint32_t* extended_array, ExtendableOutput ExtendableOutputFunction)\r\n{ // Output \"array_ndigits\" of values in [0, q-1] using an extendable-output function and a seed of size \"seed_nbytes\".\r\n  // It makes requests of values to ExtendableOutputFunction. If successful, the output is given in \"extended_array\".\r\n  // The caller is responsible for providing the \"ExtendableOutputFunction\" function passing values as 32-bit digits.\r\n\r\n    if (seed == NULL || extended_array == NULL || ExtendableOutputFunction == NULL || seed_nbytes == 0 || array_ndigits == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (ExtendableOutputFunction)(seed, seed_nbytes, array_ndigits, extended_array);\r\n}\r\n\r\n\r\nCRYPTO_STATUS stream_output(const unsigned char* seed, unsigned int seed_nbytes, unsigned char* nonce, unsigned int nonce_nbytes, unsigned int array_nbytes, unsigned char* stream_array, StreamOutput StreamOutputFunction)\r\n{ // Output \"array_nbytes\" of values using a stream cipher, a seed of size \"seed_nbytes\" and a nonce of size \"nonce_nbytes\".  \r\n  // It makes requests of values to StreamOutputFunction. If successful, the output is given in \"stream_array\".\r\n  // The caller is responsible for providing the \"StreamOutputFunction\" function passing values as octets.\r\n\r\n    if (seed == NULL || stream_array == NULL || StreamOutputFunction == NULL || seed_nbytes == 0 || nonce_nbytes == 0 || array_nbytes == 0) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }    \r\n    \r\n    return (StreamOutputFunction)(seed, seed_nbytes, nonce, nonce_nbytes, array_nbytes, stream_array);\r\n}","#include <stdlib.h>\n#include <time.h>\n#include \"LatticeCrypto_priv.h\"\n#include \"LatticeCrypto.h\"\n#include \"randombytes.h\"\n\n\nPLatticeCryptoStruct lattice;\n\nlong public_key_bytes\t= PKB_BYTES;\nlong private_key_bytes\t= 4096;\n\n\nCRYPTO_STATUS rlwejs_randombytes (unsigned int nbytes, unsigned char* random_array) {\n\trandombytes_buf(random_array, nbytes);\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS rlwejs_init () {\n\trandombytes_stir();\n\n\tlattice\t= LatticeCrypto_allocate();\n\n\treturn LatticeCrypto_initialize(\n\t\tlattice,\n\t\trlwejs_randombytes,\n\t\tNULL,\n\t\tNULL\n\t);\n}\n\nlong rlwejs_public_key_bytes () {\n\treturn public_key_bytes + 1;\n}\n\nlong rlwejs_private_key_bytes () {\n\treturn private_key_bytes + 1;\n}\n\nlong rlwejs_secret_bytes () {\n\treturn SHAREDKEY_BYTES;\n}\n\nCRYPTO_STATUS rlwejs_keypair_alice (\n\tuint8_t public_key[],\n\tint32_t private_key[]\n) {\n\tCRYPTO_STATUS status\t= KeyGeneration_A(private_key, public_key, lattice);\n\n\tpublic_key[public_key_bytes]\t= 1;\n\tprivate_key[private_key_bytes]\t= 1;\n\n\treturn status;\n}\n\nCRYPTO_STATUS rlwejs_secret_alice (\n\tuint8_t public_key[],\n\tint32_t private_key[],\n\tuint8_t* secret\n) {\n\tif (public_key[public_key_bytes] || !private_key[private_key_bytes]) {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\treturn SecretAgreement_A(public_key, private_key, secret);\n}\n\nCRYPTO_STATUS rlwejs_secret_bob (\n\tuint8_t public_key_alice[],\n\tuint8_t public_key_bob[],\n\tuint8_t* secret\n) {\n\tif (!public_key_alice[public_key_bytes]) {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\treturn SecretAgreement_B(public_key_alice, secret, public_key_bob, lattice);\n}\n"]}